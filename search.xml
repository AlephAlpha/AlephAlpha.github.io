<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试在 Hexo 中插入 LifeViewer]]></title>
    <url>%2F2019%2F03%2F12%2Ftest%2F</url>
    <content type="text"><![CDATA[测试在 Hexo 中插入 LifeViewer。 x = 59, y = 7, rule = B3/S23 o5b5ob5ob5obo3bob5ob5obobobob5ob4o$o7bo3bo5bo5bo3bo3bo3bo5bobobobo5bo 3bo$o7bo3bo5bo5bo3bo3bo3bo5bobobobo5bo3bo$o7bo3b3o3b3o3bo3bo3bo3b3o3bo bobob3o3b4o$o7bo3bo5bo5bo3bo3bo3bo5bobobobo5bo3bo$o7bo3bo5bo6bobo4bo3b o5bobobobo5bo3bo$5ob5obo5b5o3bo3b5ob5o2bobo2b5obo3bo! #C [[ COLOUR DEAD 0 0 0 COLOUR ALIVE 0 0 0 ]] #C [[ LOOP 1101 STARS NOSTEPBACK ]] #C [[ AUTOSTART X -90 Y 60 LAYERS 6 ZOOM 4 DEPTH 3 ]] #C [[ PAUSE 3 X 90 Y -60 ANGLE 20 THEME 0 ]] #C [[ PAUSE 1.5 X 90 Y 60 ANGLE 340 ZOOM 6 ]] #C [[ PAUSE 1.5 X 0 Y 0 ANGLE 0 THEME 3 ZOOM 4 ]] #C [[ PAUSE 1 X 0 DEPTH 0.2 ZOOM 6 THEME 4 ]] #C [[ T 1 THEME 7 ]] #C [[ T 400 ZOOM 5 X 5 Y -10 THEME 2 ]] #C [[ T 450 DEPTH 5 ]] #C [[ T 560 X -155 Y 127 DEPTH 0.5 ]] #C [[ T 950 X -242 Y 214 ANGLE 20 ]] #C [[ T 1050 DEPTH 0 ANGLE 0 AUTOFIT "#T" ]] #C [[ T 1100 X 0 Y 0 ZOOM 0.25 THEME CUSTOM ]] LifeViewer 是 Chris Rowett 写的一个在线版的生命游戏模拟器，功能十分强大，支持的规则很多，还可以通过脚本来控制其速度和视角。 我修改了一下 Hexo 的 NexT 主题，使得可以在文章中方便地插入 LifeViewer。 只需要修改了 NexT 主题的三个地方： 首先，下载 lv-plugin.js，放到 source/js/src/ 文件夹。 然后，在 scripts/tags/ 文件夹中放进这么一个扩展名为 .js 的文件： 'use strict';function lifeViewer(args, content) &#123; return `&lt;div class="rle"&gt;&lt;pre&gt;$&#123;content&#125;&lt;/pre&gt;&lt;canvas width="480" height="480"&gt;&lt;/canvas&gt;&lt;/div&gt;`;&#125;hexo.extend.tag.register('lifeviewer', lifeViewer, &#123;ends: true&#125;); 最后，在 layout/_custom/head.swig 文件中插入这么两行（参见此处）： &lt;meta name="LifeViewer" content="rle pre 37 hide limit"&gt;&lt;script src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/lv-plugin.js"&gt;&lt;/script&gt; 然后就能用了。比如说，要在文章中插入一架滑翔机，只需要在 MarkDown 中插入： &#123;% lifeviewer %&#125;x = 3, y = 3, rule = B3/S23bob$2bo$3o!&#123;% endlifeviewer %&#125; 效果如下： x = 3, y = 3, rule = B3/S23 bob$2bo$3o! 不过在手机上看效果不太好，LifeViewer 总是比手机屏幕要宽，不知道怎么改。 想要知道 LifeViewer 的更多用法，点击上面这个 LifeViewer 右上方的 Help 即可。例子见《π日，来吃个派》。]]></content>
      <tags>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Mathematica 搜索生命游戏中的静物（三）]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%94%A8-Mathematica-%E6%90%9C%E7%B4%A2%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E9%9D%99%E7%89%A9%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[用 Mathematica 搜索生命游戏中的静物 用 Mathematica 搜索生命游戏中的静物（二） 我把《用 Mathematica 搜索生命游戏中的静物（二）》里的代码整理了一下，写成了个叫做 LifeFind 的 Mathematica 包。现在它支持不同的规则和对称性，可以搜索静物之外的图样，但搜索速度并没有提高。可以在这里下载。 需要强调的是，我之所以用 SAT，不是因为它是最好/最快的办法，而是因为我完全不懂算法，只能用 Mathematica 里现成的函数。 以下是这个包的一些使用范例 ： 搜索之前记得下载与安装，并用以下命令来加载这个包： &lt;&lt;Life` LifeFind 的搜索是随机的，同样的搜索可能会得到不同的结果。为了确保以下范例的可重复性，我用以下的命令将每次搜索时的随机种子设为 233，顺便用 Timing 函数给出搜索在我的电脑上所花的时间。 $Pre = Function[x, SeedRandom[233]; Last@Echo[Timing@x, "Timing: ", First], HoldAll]; 搜索时间仅供参考。随机种子不同，搜索结果和搜索时间都会有很大区别。 静物1搜索生命游戏中大小不超过 16*16 的静物： 代码： LifeFind[16, 16] 搜索时间：0.941665 秒 搜索结果： x = 16, y = 16, rule = B3/S23 bo3b2ob2ob2obo$obo2bo3bobob2o$bobobob2o2bo$3b2obobobo2b2o$2bo3bo2bob2o 2bo$2b2obobobo3b3o$6bo2b3o$5obobo3b2o$o3bobob2obo2bo$2bo4bo4bobo$b3o5b 2obob2o$o4b4obobo2bo$ob3obo6bo$bo9b2o$3b2obo3bo2b3o$2b2ob2o3b2o3bo! 2搜索 B2c3-ij4ai5iy6c/S2-kn3-enq4cint 规则中大小不超过 20*20 的 C4 对称的静物： 代码： LifeFind[20, 20, "Rule" -&gt; "B2c3-ij4ai5iy6c/S2-kn3-enq4cint", "Symmetry" -&gt; "C4"] 搜索时间：1.49678 秒 搜索结果： x = 20, y = 20, rule = B2c3-ij4ai5iy6c/S2-kn3-enq4cint 2bo4bo2bo6bo$bob4ob2obo4bobo$obo4bo2bo3b2obobo$bo3bo2bo6bo2bo$2b3ob2o 5bobo2bo$2bo2bo2b5obobobo$4bobobo4bobo2bo$5bo2bo2bo3bobobo$bo3bob2o2b 4obobo$obo2bo8bo3bo$bo3bo8bo2bobo$bobob4o2b2obo3bo$obobo3bo2bo2bo$bo2b obo4bobobo$bobobob5o2bo2bo$bo2bobo5b2ob3o$bo2bo6bo2bo3bo$obob2o3bo2bo 4bobo$bobo4bob2ob4obo$2bo6bo2bo4bo! 3搜索生命游戏中在半径为 29 的圆形内的 D8 对称的静物： 代码： LifeFind[59, 59, "Symmetry" -&gt; "D8", "KnownCells" -&gt; &#123;DiskMatrix[29] _&#125;] 搜索时间：15.6273 秒 搜索结果： x = 59, y = 59, rule = B3/S23 25b2o5b2o$24bobo2bo2bobo$19b2o2bo2bobobobo2bo2b2o$20b4ob2obobob2ob4o$ 18bo5bo3bobo3bo5bo$12b2o3bob4obo3bobo3bob4obo3b2o$11bo2bo2bobo2bobob2o bob2obobo2bobo2bo2bo$11b2o2bobo3bo2bo2bo3bo2bo2bo3bobo2b2o$13b2o2bo2b 2obobo2b3o2bobob2o2bo2b2o$11b2o4bobo3bob3o3b3obo3bobo4b2o$10bo2b4o2b2o b2o4bobo4b2ob2o2b4o2bo$6b2obobobo3b2o5b2o2bobo2b2o5b2o3bobobob2o$5bobo bo2bo3bo2bob2obobobobobobob2obo2bo3bo2bobobo$5bo2bob2o3bo2bo3bobob2obo b2obobo3bo2bo3b2obo2bo$6bobobo3bo4b3o2bo4bo4bo2b3o4bo3bobobo$7bo2bo2bo b4o3b2ob2obobob2ob2o3b4obo2bo2bo$10bobo2bo2bobo2bo2bobobobo2bo2bobo2bo 2bobo$5b5obo3bo2bob2o2bobobobobobo2b2obo2bo3bob5o$4bo6bobob4o2bob2o2bo 3bo2b2obo2b4obobo6bo$2bo2b2o2b2obobo4bobo2bo3b3o3bo2bobo4bobob2o2b2o2b o$2b2obo2bobo3bob2o2bobo2b3o3b3o2bobo2b2obo3bobo2bob2o$3bobob2o3bobo2b 3o2b3o2bobobo2b3o2b3o2bobo3b2obobo$3bob2o3bob2obo4b2o3bo2bobo2bo3b2o4b ob2obo3b2obo$2b2o4b3o4b2obo2bo2bo4bo4bo2bo2bob2o4b3o4b2o$bo2b4o3b4o2b 3obobo11bobob3o2b4o3b4o2bo$o2bo4b2obo3bo4bobo13bobo4bo3bob2o4bo2bo$4o 2bo2bo2b2ob3o2bo5b2o3b2o5bo2b3ob2o2bo2bo2b4o$6b2obo3bo4bob2o4b2o3b2o4b 2obo4bo3bob2o$2b4o2bob3o2b3obo2bo13bo2bob3o2b3obo2b4o$bo4bobo4b2o4bobo bo11bobobo4b2o4bobo4bo$2b4o2bob3o2b3obo2bo13bo2bob3o2b3obo2b4o$6b2obo 3bo4bob2o4b2o3b2o4b2obo4bo3bob2o$4o2bo2bo2b2ob3o2bo5b2o3b2o5bo2b3ob2o 2bo2bo2b4o$o2bo4b2obo3bo4bobo13bobo4bo3bob2o4bo2bo$bo2b4o3b4o2b3obobo 11bobob3o2b4o3b4o2bo$2b2o4b3o4b2obo2bo2bo4bo4bo2bo2bob2o4b3o4b2o$3bob 2o3bob2obo4b2o3bo2bobo2bo3b2o4bob2obo3b2obo$3bobob2o3bobo2b3o2b3o2bobo bo2b3o2b3o2bobo3b2obobo$2b2obo2bobo3bob2o2bobo2b3o3b3o2bobo2b2obo3bobo 2bob2o$2bo2b2o2b2obobo4bobo2bo3b3o3bo2bobo4bobob2o2b2o2bo$4bo6bobob4o 2bob2o2bo3bo2b2obo2b4obobo6bo$5b5obo3bo2bob2o2bobobobobobo2b2obo2bo3bo b5o$10bobo2bo2bobo2bo2bobobobo2bo2bobo2bo2bobo$7bo2bo2bob4o3b2ob2obobo b2ob2o3b4obo2bo2bo$6bobobo3bo4b3o2bo4bo4bo2b3o4bo3bobobo$5bo2bob2o3bo 2bo3bobob2obob2obobo3bo2bo3b2obo2bo$5bobobo2bo3bo2bob2obobobobobobob2o bo2bo3bo2bobobo$6b2obobobo3b2o5b2o2bobo2b2o5b2o3bobobob2o$10bo2b4o2b2o b2o4bobo4b2ob2o2b4o2bo$11b2o4bobo3bob3o3b3obo3bobo4b2o$13b2o2bo2b2obob o2b3o2bobob2o2bo2b2o$11b2o2bobo3bo2bo2bo3bo2bo2bo3bobo2b2o$11bo2bo2bob o2bobob2obob2obobo2bobo2bo2bo$12b2o3bob4obo3bobo3bob4obo3b2o$18bo5bo3b obo3bo5bo$20b4ob2obobob2ob4o$19b2o2bo2bobobobo2bo2b2o$24bobo2bo2bobo$ 25b2o5b2o! 4搜索生命游戏中大小不超过 10*10，恢复时间不超过 4 的 glider eater： 这里多搜了一代，以确保搜到的是静物。 代码： LifeFind[10, 10, 6, "Rule" -&gt; "B3/S23", "Periodic" -&gt; False, "KnownCells" -&gt; Join[&#123;&#123;&#123;0, 1, 0&#125;, &#123;0, 0, 1&#125;, &#123;1, 1, 1&#125;&#125;&#125;, Table[&#123;&#125;, 3], Table[0, 2, 4, 4]], "OtherConditions" -&gt; Array[If[Max[##] &lt;= 3, True, C[##, 1] \[Equivalent] C[##, 5] \[Equivalent] C[##, 6]] &amp;, &#123;10, 10&#125;, 1, And]] 搜索时间：2.97737 秒 搜索结果： x = 10, y = 10, rule = B3/S23 bo$2bo2b2o$3o3bo$6bob2o$3b2obob2o$4bobo$2bobobo$bob2obob2o$bo4bo2bo$2o 4b2o! 振荡子5搜索生命游戏中大小不超过 16*16 的周期为 3 的振荡子： 代码： LifeFind[16, 16, 3] 搜索时间：343.556 秒 搜索结果： x = 16, y = 16, rule = B3/S23 4b2ob2o3bo2bo$5bobo4b4o$bobo3bo2b2o$ob6obo3b3o$o7bo2b2o2bo$bob2obo2b2o 2b2o$2b2obob2o2bo$5bo2bo2b4o$2b2o2bo8bo$2bo4bo5b3o$2b2obob2o3bo$2b2o3b o2bo2bo$b3o2bob2o3bo$o4b3o3b2o$2o2bob3o$4bob2o! 6搜索生命游戏中大小不超过 8*8 的周期为 5 的 D8 对称的振荡子： 通过设置 &quot;Changing&quot; -&gt; True 来避免搜到静物。这里搜到的是 Octagon 2。 代码： LifeFind[8, 8, 5, "Symmetry" -&gt; "D8", "Changing" -&gt; True] 搜索时间：1.76343 秒 搜索结果： x = 8, y = 8, rule = B3/S23 $2bo2bo$bob2obo$2bo2bo$2bo2bo$bob2obo$2bo2bo! 7搜索生命游戏中大小不超过 6*6 的周期为 4 的振荡子： 通过设置 &quot;Changing&quot; -&gt; {1, 3} 来避免搜到静物或者周期 2 的振荡子。这里搜到的是 Mold。 代码： LifeFind[6, 6, 4, "Changing" -&gt; &#123;1, 3&#125;] 搜索时间：0.655831 秒 搜索结果： x = 6, y = 6, rule = B3/S23 $3o$3obo$bobobo$2bo2bo$3b2o! 8搜索生命游戏中大小不超过 16*16 的周期为 2 的凤凰： 代码： LifeFind[16, 16, 2, "OtherConditions" -&gt; Array[! C[##, 1] || ! C[##, 2] &amp;, &#123;16, 16&#125;, 1, And]] 搜索时间：4.2407 秒 搜索结果： x = 16, y = 16, rule = B3/S23 $12bo$10bobo$14bo$8b2o$14b2o$9bo$11bobo$7bo3bo$5bobo$9bo$3b2o$9b2o$4bo $6bobo$6bo! 9搜索3457/357/5 规则中大小不超过 7*7 的周期为 5 的振荡子： 代码： LifeFind[7, 7, 5, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True] 搜索时间：18.3763 秒 搜索结果： x = 7, y = 7, rule = 3457/357/5 .AB$C2AC$D2AD$2.AC.A$3.B2AB$3.3AC$5.D! 10搜索未知的规则中大小不超过 5*5 的周期为 11 的振荡子： 代码： LifeFind[5, 5, 11, "Rule" -&gt; "", "Changing" -&gt; True] 搜索时间：17.162 秒 搜索结果： x = 5, y = 5, rule = B2k3n4jnry5eiry7c8/S2ck3aeijnqr4erwyz5aijqr6aekn7e8 bobo$2b3o$3obo$5o$3bo! 11搜索未知的有 4 种状态的 Generations 规则中大小不超过 5*5 的周期为 11 的振荡子： 代码： LifeFind[5, 5, 11, "Rule" -&gt; "", "Generations" -&gt; 4, "Changing" -&gt; True] 搜索时间：63.1457 秒 搜索结果： x = 5, y = 5, rule = 2cik3ijr4aenqwy5ijk6ce/3e4aqw5y6ak/4 .A.A$ABA.A$A2CA$A2CBA$.3A! 12搜索一个规则，使得生命游戏中的滑翔机在这个规则中是一个周期 48 的 Reflectorless rotating oscillator；具体地说，在 12 代之后向右平移 6 格并顺时针旋转 90 度： 我们只需搜索 13 代，就能让搜到的图样满足条件。注意要设置 &quot;Periodic&quot; -&gt; False。 代码： LifeFind[5, 11, 13, "Rule" -&gt; "", "Periodic" -&gt; False, "KnownCells" -&gt; Join[&#123;ArrayPad[&#123;&#123;0, 1, 0&#125;, &#123;0, 0, 1&#125;, &#123;1, 1, 1&#125;&#125;, &#123;&#123;1, 1&#125;, &#123;1, 7&#125;&#125;, 0]&#125;, Table[&#123;&#125;, 11], &#123;ArrayPad[&#123;&#123;1, 0, 0&#125;, &#123;1, 0, 1&#125;, &#123;1, 1, 0&#125;&#125;, &#123;&#123;1, 1&#125;, &#123;7, 1&#125;&#125;, 0]&#125;]] 搜索时间：37.1343 秒 搜索结果： x = 11, y = 5, rule = B2ceik3y4ckqw5kr6cn/S01ce2eikn3eiq4jn5akn6ek $2bo$3bo$b3o! 飞船13搜索生命游戏中大小不超过 5*16，周期为 3，速度为 c/3 的竖直方向的飞船： 这里搜到的是 25P3H1V0.1。 代码： LifeFind[5, 16, 3, 1, 0] 搜索时间：1.23444 秒 搜索结果： x = 16, y = 5, rule = B3/S23 o2bo$b2o2bo3b2obo2bo$b2ob2o2bo4b2o$5b3ob3ob2o$7bo! 14搜索生命游戏中大小不超过 12*15，周期为 5，速度为 2c/5 的 D2 对称的竖直方向的飞船： 这里搜到的是 44P5H2V0。 代码： LifeFind[12, 15, 5, 2, 0, "Symmetry" -&gt; "D2|"] 搜索时间：526.74 秒 搜索结果： x = 15, y = 12, rule = B3/S23 4bobobobo$b3o7b3o$2o11b2o$3bo7bo$2b2o7b2o$b2o9b2o$2ob2o5b2ob2o$2bo2bo 3bo2bo$2b2ob2ob2ob2o$3bobo3bobo$4bo5bo! 15搜索生命游戏中大小不超过 21*21，周期为 4，速度为 c/2 的 glide symmetric 的竖直方向的飞船： 代码： LifeFind[21, 21, 4, 2, 0, "OtherConditions" -&gt; Array[C[##, 1] \[Equivalent] C[# + 1, 21 + 1 - #2, 3] &amp;, &#123;21, 21&#125;, 1, And]] 搜索时间：42.8359 秒 搜索结果： x = 21, y = 21, rule = B3/S23 $4bo$3bo2bo2b2o5b2o$3bo4bo6bo$10bo5bo$4b2obob5obo$6bo6b3o$8bobo$2b2o7b o6b2o$2b3o6bo6b3o$bob2o3bo2bo5bob2o$b3o5b3o5b3o$2bo15bo3$4b2o4b2o4b2o$ 4b3o3b3o3b3o$3bob2o2bob2o2bob2o$3b3o3b3o3b3o$4bo5bo5bo! 16搜索 B2-ak3ain/S1 规则中大小不超过 10*10，周期为 5，速度为 c/5 的 D2 对称的对角方向的飞船： 代码： LifeFind[10, 10, 5, 1, 1, "Rule" -&gt; "B2-ak3ain/S1", "Symmetry" -&gt; "D2\\"] 搜索时间：1.63345 秒 搜索结果： x = 10, y = 10, rule = B2-ak3ain/S1 $6bo$5bobo$5bo2bo$5bobo$2b3o$bo$2bobo$3bo! 17搜索上面搜到的飞船的大小不超过 15*15 的 D2 对称的 tagalong： 代码： LifeFind[15, 15, 5, 1, 1, "Rule" -&gt; "B2-ak3ain/S1", "Symmetry" -&gt; "D2\\", "KnownCells" -&gt; &#123;ArrayPad[ FromRLE@"x = 10, y = 10, rule = B2-ak3ain/S1\n\$6bo$5bobo$5bo2bo$5bobo$2b3o$bo$2bobo$3bo!", &#123;&#123;5, 1&#125;, &#123;5, 1&#125;&#125;, _]&#125;] 搜索时间：4.2824 秒 搜索结果： x = 15, y = 15, rule = B2-ak3ain/S1 $8bo$10bo$10bo$10bo2$11bo$10bobo$bo8bo2bo$10bobo$2b3o2b3o$6bo$7bobo$8b o! 18搜索 B02-ak3ai/S1 规则中大小不超过 16*16，周期为 4，速度为 c/4 的 glide symmetric 的对角方向的飞船： 代码： LifeFind[16, 16, 4, 1, 1, "Rule" -&gt; "B02-ak3ai/S1", "OtherConditions" -&gt; Array[C[##, 1] \[Equivalent] C[#2 + 1, #1, 3] &amp;, &#123;16, 16&#125;, 1, And]] 搜索时间：2.79788 秒 搜索结果： x = 16, y = 16, rule = B02-ak3ai/S1 2$8bo$5bob2o$3b5ob2o$3b6o$3b9o$3b9o$3b9o$2bo2b7o$5b7o$4bo2b2o2bo! 19搜索未知的规则中大小不超过 5*5，周期为 6，速度为 (2,1)c/6 的马行船： 代码： LifeFind[5, 5, 6, 2, 1, "Rule" -&gt; ""] 搜索时间：9.79478 秒 搜索结果： x = 5, y = 5, rule = B2ceik3ckn4knqr5akq7c/S1e2cek3aeijq4jz5jkq6c 2o$2b2o$3bo$obo! 20搜索未知的 totalistic 六边形规则中大小不超过 8*8，周期为 3，速度为 c/3 的对角方向的飞船： 代码： LifeFind[8, 8, 3, 1, 1, "Rule" -&gt; "", "Hexagonal" -&gt; True, "Totalistic" -&gt; True, "Changing" -&gt; True] 搜索时间：2.15809 秒 搜索结果： x = 8, y = 8, rule = B245/S356H bo$3o$b2ob2o$3bob2o$2bob4o$2b5o$3b3o$4bo! 21搜索一个规则，使得生命游戏中的滑翔机在这个规则中是一个周期 7 速度为 (3,1)c/7 的骆行船： 代码： LifeFind[17, 17, 7, 3, 1, "Rule" -&gt; "", "Changing" -&gt; True, "KnownCells" -&gt; &#123;ArrayPad[&#123;&#123;0, 1, 0&#125;, &#123;0, 0, 1&#125;, &#123;1, 1, 1&#125;&#125;, 7]&#125;] 搜索时间：130.006 秒 搜索结果： x = 17, y = 17, rule = B2ek3aein4aikr5cnr/S1e2ei3aeijknr4k5ckn6a 7$8bo$9bo$7b3o! 22搜索未知的规则中在第一回合的大小不超过 3*3，周期为 7，速度为 2c/7 的对角方向的飞船，使得生命游戏中的滑翔机在这个规则中也成立： 代码： LifeFind[11, 11, 7, 2, 2, "Rule" -&gt; "", "Changing" -&gt; True, "KnownCells" -&gt; &#123;ArrayPad[Table[_, 3, 3], 4]&#125;, "KnownRules" -&gt; PatternRules@CA[&#123;&#123;0, 1, 0&#125;, &#123;0, 0, 1&#125;, &#123;1, 1, 1&#125;&#125;, 4]] 搜索时间：53.9408 秒 搜索结果： x = 11, y = 11, rule = B3aijnr4kq7c8/S02aen3ajknr4ijrw5air6akn7c 4$5b2o$4bobo$4b3o! 其它23搜索生命游戏中大小为 5*5 的周期 4 的琼脂： 代码： LifeFind[5, 5, 4, "Agar" -&gt; True, "Changing" -&gt; &#123;1, 3&#125;] 搜索时间：5.48619 秒 搜索结果： x = 5, y = 5, rule = B3/S23:T5,5 b3o$4bo$3bo$2o2bo! 24搜索刘看山的父母： 也可以用包里的 Predecessor 函数。 代码： LifeFind[100, 100, 2, "Periodic" -&gt; False, "KnownCells" -&gt; &#123;&#123;&#125;, ImageData[ 1 - Binarize[ ImageResize[Import@"https://pic4.zhimg.com/da8e974dc_xl.jpg", 100], 0.8], "Bit"]&#125;] 搜索时间：125.216 秒 搜索结果： x = 100, y = 100, rule = B3/S23 9bobob2o5bob2ob2ob2obo3bo10bo4bo5bo2bo5bo3b2ob2o4bo5bo6bob2obo$2bob2o 2bo3b5o4b10o9bobo3bo2bo3bobo2bo3bobo2bo15bo5bo3b4o$o2b8obobo3b3obobo2b 4obo4bobo5b3o2b3o3b6o3b12obo3bo6bo2b5obo$4b5o3b2obob4ob2ob2ob4o2b2o2b 4o2bobob3ob4ob2ob3ob3obob4ob3o2b4o2bob5o2bo2bo$o3bobo5b7ob2ob2ob2ob2ob 7ob6ob4ob3ob3ob10o3bob2o5bobo2b4ob5o$2bob3o3bobo3b3obobob5ob2obo3bo2b 3o2bob2obo2bobobo2bo2b2o2b2o2bob2obo5b5o3b8o$obob4o3bobo3bob3ob2ob3obo 2b2ob3o2b6ob10o2b3obo2b2o3bob3obo2b3obobo3b2o2b3o$b4ob6o3bo2b16ob4ob2o 2b8obo2b2ob2ob3ob3obob2obobo2bob3o4bo5b4o$2bobobo2b2obo6bo2b2ob4o2b2ob 2obo2b4o5bo3b2ob4obob6o3b3obob4ob2ob3o5b2ob2o$2bob3o7bo3bo3bob3o4b2ob 2obo2b2ob2obo2bo3b2o2b2o2b5o3b3obo2b2ob2obo2b3ob3obob3o$4b4o8bo4b2o2b 2o5b2o2b3ob2ob2obo7b6ob3o2b5ob2ob6ob2o2bob10obo$2bob6o7b7o2bobo2b2o2bo bob2obob4o4bo2bob3o2bo2b2ob2ob5o2bob3ob8obo2b2obo$4b2obo3b2ob6ob2ob3ob o2b2o4b5obo2b4o2bob7o2bob3obobo2b2o2b6obo3b4o2b2o$2bobob3ob6obobob3obo b4ob6o4b2o4b8ob2ob6obob3o4b5ob4ob4obob3o$o2bob7ob3obob2o3b3ob3ob3ob3o 2bob2o3b2ob6o4b2ob5ob2obob6ob4o3b2ob5ob2o$b2ob2obobob8obob4o3b2obo4b2o 4b2o2b2o4bo2b3ob2obobobo2bo2bob2o3bobob2o5b2o3bo$2ob2o2bobob2o5b3o3b2o 3b11o2bob6ob4ob7obob6o4b2ob9o3bo3b2ob2o$3o2b6o4bob3ob2o2bob2o4b3o2bobo 4bo2b7ob2o4b4o2bo2b4ob2ob3o3bo3bob6o$bobob2o2b4o2bob3ob3ob5ob2o3b2o7bo b3o4b4obo3b3obobobob3o2b3o2bobo4b6o2b2o$bo3bo2b3o3b4o2b2ob2obo2b10obo 2b4ob3obob2obobo3b2ob8o2b6obo5b2obob2o$6ob2ob3ob9ob3o3b4ob2ob2o5bobob 2obob2ob4ob3obo2b5obob5o3bo3b2obobo$5ob2o2bo3b3obob4o2b4obo4b4obo3b3o 2b4o2b2ob2ob2ob3o5bo5b3o5b2ob5o2bo$bob2ob5o3b6o2b6ob2o5b2o2bo2b2ob3obo 2b6obobob2ob3obob4ob4ob6o2bo2b2o3bo$bo2bob2o2b2ob8o3b2o2bobobo2b3ob7ob 3obobo2b2obobobo2b2o4b2ob4ob5ob3o2bob3obobo$3bobob2o2b5ob4ob2obobobobo 3b6ob2ob2ob2o3b2o4b7obob2ob4ob2o6b2o2b5obobo$5b3ob5ob2o2b5ob10ob12o2bo 2b3ob3ob2o2b3o4bo2bob12ob3ob2o3bo$5b2ob2o2b2o2bo5bob3o2b3ob3ob2o2bobo 2bo2b4ob2ob3ob3obob3obob4o3b5o2b2o2b8o$2o4b3o3b2ob5o3b5obob5o5b2ob4ob 6o3bo3b2ob9o2b2o9b2o2bobo3b3o$3bo2b2o2bob5ob5o2bob4o3b2o4b3ob11obo2b2o b2ob4ob5ob2o4bo5bob2ob2ob4o$7bo3b3o3bo2bob2ob5o2bob4o2b5obo4b3o2b3o3b 2o2b2o2b2ob2o2bobobo2bobob2ob6obo$6bob3o2b5o2b2ob3ob3o4bob4o2bob2o3bob obobo2b2ob2o2bobo2b4o2b2o2b4o3b2ob4ob2obo$ob2o4b4ob3ob2ob4o2b2o2b5o2b 2ob2o2bo3bo2b3o3b2obob5ob2obob4ob3ob4obob2obobobo$b8obob3ob3o2b10ob4o 2b4obob6obobob2o5b2ob4obob5ob2ob2o3b2o2bob3obo$2bob6o2bo3b4o4bo3b3o2bo b4o3b3ob2ob4o3b2o3bo3bobobo3bobob5o2b6ob3obo$obobobo2b2ob4o3b4o2b4o2b 2ob2ob2o2bobo4b6o3b2o6b3ob2o2b2ob2o3bo2b3ob8obo$b5o4b6o2b6ob6ob2o2b4o 4b3ob5obob3o3b2ob2ob7o2b2o2b2ob12o2bo$2b3o3bobobob3ob2ob2obobob3o2bobo b7ob3ob2ob2o2b2ob2o4b4obo2b9obo7b5o$ob2obo4b6obobo3bobo2bobob2o5bob2ob 5o3b2o2bo2b3obo2bo2b3obo2bob2ob2ob2o2bo5b2obo$2b2o4bob4o3b2o2b5ob3ob2o bo5b3o2bob2o3bo2b2obo2b2o2bo2bob3ob3o8bob3obo3b2o$bob2o4b5o3b3o3b2ob3o 2bo6bob2obo2b3ob3obob4ob3o7bo7bo2bo3bobob3ob2o3bo$4b3o3bo2b2obob2obo2b 3o3b4o2bo2b2o6b5obo2b10ob2o4b2o4bo4bo2bo2bo4bo$bobob6obob3ob3o2bo3b5o 8bo4bo2bo5bobob4ob14ob2ob2o3b2o3bo2bo3bo$5b6o3bobobob3ob2ob2ob4o2bo2b 2obobo3bo3bo3b2o3b3obo4b3obo3bo2b2obo5bob2obo$bobob6o2b3o2b2o2b2o3b2ob 2o3bo3b2o2b3o2bo2bo4b2obob3o2b5ob3o5b2o2bo4b5o2bo2bo$5bo3b2obobobob2ob 3o2bob2o10bo5b9ob3o2b2o2b3obo2b4obo3bob2o5b2o2bo3bo$o3b7o3b3ob2ob5o3bo 4bo2b3o2b2ob2o2bo2b4o3b4ob2o3b2o2b3o2bo6bo2bo4b2o2b3o$4b11o3bo2b4obob 2ob2o2b2obob6ob5o2bo2b5ob3o3b5o2bobob2o2bobo2b2o2b2o2b3o$bob3o2bo2b2o 2bob3ob3o4b2ob2o2b4ob2o4b3obob2ob5o2b4obob2o2b2o3b2o2b2o3b2o2bo3bob2o$ 2b2obo2b2obobobob3o2bobobo5b4ob2o2b2o2b2o3b2ob3o3bobo4bo2bob2ob3o6bo2b obo8b3o$b2o2b4ob2o3bob6o9bo2bo2bo2b2o2b4ob4ob5o3bobob5ob2ob2o2bo4b3o3b ob2o2b3o$b5ob2ob2o2bob2obob2o4bob2ob8ob4o2b10obobo3b4o2b5o2bo3bob2o2bo 2bo2bo2b3o$2bo2bob4o6bob3o6b5obobobob2o2b3o6bo2bob7obobo3bob3obo2bo3bo bobo2bo2b3obo$o2bob2o3b2o3bob5obo3b6o2b2obobo7bobob4obob3obo2bo5b5obo 2bo5bobo3b2obo$5b4ob2o2bob3ob2o3b8o3b5o2b2obo4b2obobobobo2b2o3bo2b3o3b 2obo2bo6bob2ob2o$bo3bob4o6bo4b5ob4o3b6ob2o2bo5b2o2b8ob3o2bob3o2bo2bo4b obo2bob2ob2obo$2bob2o2bobobo2bo2b3ob2ob2o4b6ob3obo5b2o2b2ob2obob5ob2ob 6o2bo4bo4b2o3bo3b2o$b3ob3o2b2o3b7o2bobo3bobobob6o3bob5o2bob5o3b6o5b2o 2bobo2b2obo3b2o3bo$ob3ob6obo3b5ob2ob2o5b6o3b2ob3obob4o2b2ob3ob5o2b2o2b 2o2bobo2b2o2bo2b3ob3o$4bob2o2bo2bo5b2o2b10o2b2o3b6o2b2obo2b5o2b3ob4o7b obo4bo6b2ob2ob4o$ob2ob2o4bo3bo5b2obo4b3ob4ob6o2bo2b2obob2ob2obo2b15o3b o6bob4obobo$b3ob2obo5bo2bo3b2ob2o2bob4ob2o3b2o2b4ob6obobo3bobo3b2ob6o 3bobobo3bob3o2b5o$2bo3bobo5b2obo2b2o2b2o5bob4o3bo2bob2ob2ob5ob7o2b2o3b obobobo7bob6o2b3o$bob2ob5obobob6obob6obob2o3b2o6b2ob5ob2ob2obob5ob5o4b 2obob4obo3b2o$3b6o5bo2bo2b2o4b10o3b3o5b2ob3obobob17ob2o5b3o2bobo2b5o$ 2bobob3o5bo2bo2b2obobo5b2obo3b3obobo3bobobob2ob4o2b4o3bobo2b2o7b9o3b4o $4bob2o3b2obob4o2bo4b2obob3o2bob2o5bob2ob2ob3o8bo3b3o6bo5bo2b3ob3o3bo$ 3b3ob8ob3ob2ob9obob4ob6o2b2ob2ob3obo4b8o2b2ob2o4bob3obob4o2bo$b4obobob o4b4ob5obobob5obobob3ob2ob5obob2o2bobo3b3o5b5obo2bob5o2bob2o$3bob2o2b 2obo3b2obo6b2ob3ob3obob3obo2b5o2b3ob4o10b3obobo3b3obob3obob3o$ob2o2b5o 3b2o2b2ob2o3b3obob2ob3ob4obob2ob2ob2ob5o4bobob7ob6o2bo3b2o4b4obo$b3ob 4obobobob4o4b3o2bob2ob4obo3b3o2b2o2b3ob4obo2bobob2ob2obob5o3b3ob2obob 2ob3o$2b3obo2b3o2bob4o6bo2b2o2bob3ob2o2bo2b6o2b3ob3o9b3ob2o2b2o2bob6ob ob7o$bob3obo2bo3b4o2b2o2b5ob6obob8obo2b4ob2o2bobo4b2o2bob2o2bo2b2o2bob o3b4o3b3o$5bo4bobo4bob7obob4o2b3obobo2b4o2bo2bob2o2b2o4b4obo2b6ob2ob2o bobob2o2b3obo$bob3o6bo3bobob3o2b2obo2b2obobob3o2bob2o5bo2b3ob9o5b2o2bo b2o2b2o3bobo2b4obo$o4b2o3bo3bo3b5o3bob2o3b8ob5o8bob2o2bob5o2bo3b4obo2b obobo3b4ob2o$5bobo2bobo5b5obob4ob3o2bo2bo2b2ob2obo2bo2b2ob2obo2bob5o2b ob5ob5obobob8o$bob3o6bo4b6o2b3o2b3o4bo2bob3obo2bo4b2o2bo4b2ob2o5bo3b4o b2ob3o2b5ob4o$2b3obo3bo3bo2b3obo2b2ob2obobo9b2ob2ob6o2b2ob4ob2o3bo2b2o bo3bo2b2ob2o3b2obobobo$obobo4bo3bo2b2obobob3o2b2ob3o3bo4bob6ob3ob2obob 2ob5ob5o6b2ob3ob3ob4ob2o$bobob6o2bob5o3b2o2bo2b4o2bo3b4o2bob3o3bobob2o bobobo3bo2b2o2bobob4o2b4ob7obo$3ob2ob2ob4ob5o3b2o4b2ob3o7b4ob2o2b5ob2o b4o2b3o2bobobo4b2obobob4ob3ob3o$3o2b3ob2o4b3o2b2obo3bob2ob3obo8b2o2bob 5o2bob2ob3ob2o4b7o2b2o3bo3b5obo$b2obo3b2o4b2obo2b4o3bo2bo2b3o6b2ob6o3b 3ob4ob3obo2bo2b2ob3obob2o2b2obob2o3bobo$b6o2b5ob5ob3ob7obobobob2o4b2ob ob4ob4o3bobob2o2bo3b2o3b10o2bo3b2o$2b3o4b2obo3bo2b2obob4o2bobob2o2b4ob 2o3b3ob2ob3o3b2o2b4o5b2obob2o2bobobob4o2b2obo$2b2o6bo5b6o2b2o2b2o2b2ob 2obobob3o3b6o2b2o3b2o3b3o2bo3bo2b2o3b2o2b3ob4obobo$obo2bo4b2ob2ob7o2b 8o2b7o2b2ob2o5bobo5bobobobo6b2obo2bob2ob7ob6o$b2o4bob2obo3bo2bob3ob3ob 2o2bobo2bob2ob3ob3ob5obo2bob2o2b3o4b3ob2o3b2obob4o3b2o2b2o$4o4b3o2b5ob o2b4obob8o2b2obob4ob7o3bo2b3ob2obob5o2b2o3bob4o3b4ob2o$2ob3o3bo3b5o3bo 2bob6o2b2ob2obob7obo4b7obob2o3b3ob2o2b2o2bob2o8bobob2o$bob9o2bobob6o2b 11ob2ob5o3b2ob3obob9o3b4ob3ob5o2bo3bo4b5o$ob3ob4obo2b2ob2ob4ob2o4b2obo 2b3ob5obo2b4ob2obobo2bo2bobo2b2obo2b3o2bobo4bo2bo3bobo$2b3o4bo2bob3o2b 2ob4obobobobob2o2bob3obo2b2obob2ob2ob4ob3obo2b5o2b2obob9o2bobob2o$b2o 2bob3o2bo2bobob2o4bo4b2ob4ob4ob2obob3o2bob3obob3ob2o3b3obob3ob3obob7ob o3b2o$b9obob6obob2ob6obob2ob2o2bob2o3b2ob3ob6obobobo2bobo2b8o3b5obob6o $2bo2bo2bo3b5ob2ob4ob2ob5ob2obob2o2b9ob2o3bo2b2ob5obob3o6b3o5bo2bobob 3o$bo2bo3bo2bo7bob5o2b4o2b2obobob5ob4o3bobo3bob2ob3o5b3obo2b7o2bob3o2b ob2o$7b4obob2ob6o3bo2bo3bo2b4o2b2o7b4o4b10o3bobo2bo4bobo6b8o$bo4bob2o 9b2o3bo4bo5bob2obo4b2obobob2obo2bob2ob2ob2ob2o4bo6bobo5bob2o2b2obo!]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wolfram|Alpha 计算时显示的元胞自动机（三）]]></title>
    <url>%2F2019%2F03%2F02%2FWolfram-Alpha-%E8%AE%A1%E7%AE%97%E6%97%B6%E6%98%BE%E7%A4%BA%E7%9A%84%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Wolfram|Alpha 计算时显示的元胞自动机（一） Wolfram|Alpha 计算时显示的元胞自动机（二） 现在我给 LifeFind （即前面提到的用来搜索生命游戏中的图样的那个 Mathematica 包）加上了搜索 Generations 规则的功能。于是，它也能够搜 Wolfram|Alpha 的那个元胞自动机。 搜索速度很慢，而且只能搜周期很小的图样，于是其实没有太多有意思的发现。不过，至少振荡子不再只有那么几个了。 运行以下的 Mathematica 代码之前先要导入 LifeFind 包（当然，导入之前先要安装）： &lt;&lt; Life` 搜索结果是随机的。输入下面的代码来搜索很可能会搜出不同的图样。 静物静物没什么好说的。原本就能搜 B357/S3457 规则的静物，只是现在可以把这个规则写成 3457/357/5 了。 还可以加点别的条件，搜个胖乎乎圆滚滚的，好看。 LifeFind[59, 59, "Rule" -&gt; "3457/357/5", "Symmetry" -&gt; "D8", "KnownCells" -&gt; &#123;DiskMatrix[29] _&#125;] 搜出的结果： x = 59, y = 59, rule = 3457/357/5 25bo7bo$23b5obob5o$18b2ob3ob2ob3ob2ob3ob2o$17bob2obobo2b2ob2o2bobob2ob o$17b2obob2o2bo2bo2bo2b2obob2o$13b2ob2ob3obob2o2bo2b2obob3ob2ob2o$13b 2obob2obobo2bob3obo2bobob2obob2o$14bob2obo2b5o2bo2b5o2bob2obo$11bo2b2o bob3o3bo2bobo2bo3b3obob2o2bo$9b5ob2ob3obo3bob3obo3bob3ob2ob5o$9b2ob2ob o2bo2b5obobobob5o2bo2bob2ob2o$8b2o2bob6o2b2o2bo5bo2b2o2b6obo2b2o$9b4ob o2bob2o5b2obob2o5b2obo2bob4o$5b2o2b2o2b3obo2b2ob3o2b3o2b3ob2o2bob3o2b 2o2b2o$5b4o2b3o2bobo2b2ob2o2bobo2b2ob2o2bobo2b3o2b4o$8b4obobo2b2o2bobo b2obob2obobo2b2o2bobob4o$5b3obobo2bob3o3bob2o2bobo2b2obo3b3obo2bobob3o $3b3ob2o2b3o2b2o2bob2o2bo2bo2bo2b2obo2b2o2b3o2b2ob3o$2bobobo2b3o2b3o2b 4o2bob2ob2obo2b4o2b3o2b3o2bobobo$2b2ob5ob2o2bo2b2obo2b11o2bob2o2bo2b2o b5ob2o$3b3o2b2o2b2o3b2o2b3obo7bob3o2b2o3b2o2b2o2b3o$2bo2b2obobo2b2o3b 4ob2ob7ob2ob4o3b2o2bobob2o2bo$2b3o2bob3o2b5obobob3o2bo2b3obobob5o2b3ob o2b3o$b2ob4o2b2obo3bo2b2ob2o9b2ob2o2bo3bob2o2b4ob2o$bobo3bo2bo2b4o2bob 3ob2o2bo2b2ob3obo2b4o2bo2bo3bobo$3o2bob2obo2b2obob3obob11obob3obob2o2b ob2obo2b3o$b2ob4obob2o2bobobob2ob4obob4ob2obobobo2b2obob4ob2o$bobo6bob o2bo2b2obo3b2o2bo2b2o3bob2o2bo2bobo6bobo$2b2o2bob2o3b2obob2obo3bo2bobo 2bo3bob2obob2o3b2obo2b2o$b2ob4ob2ob2obobobob2ob4obob4ob2obobobob2ob2ob 4ob2o$2b2o2bob2o3b2obob2obo3bo2bobo2bo3bob2obob2o3b2obo2b2o$bobo6bobo 2bo2b2obo3b2o2bo2b2o3bob2o2bo2bobo6bobo$b2ob4obob2o2bobobob2ob4obob4ob 2obobobo2b2obob4ob2o$3o2bob2obo2b2obob3obob11obob3obob2o2bob2obo2b3o$b obo3bo2bo2b4o2bob3ob2o2bo2b2ob3obo2b4o2bo2bo3bobo$b2ob4o2b2obo3bo2b2ob 2o9b2ob2o2bo3bob2o2b4ob2o$2b3o2bob3o2b5obobob3o2bo2b3obobob5o2b3obo2b 3o$2bo2b2obobo2b2o3b4ob2ob7ob2ob4o3b2o2bobob2o2bo$3b3o2b2o2b2o3b2o2b3o bo7bob3o2b2o3b2o2b2o2b3o$2b2ob5ob2o2bo2b2obo2b11o2bob2o2bo2b2ob5ob2o$ 2bobobo2b3o2b3o2b4o2bob2ob2obo2b4o2b3o2b3o2bobobo$3b3ob2o2b3o2b2o2bob 2o2bo2bo2bo2b2obo2b2o2b3o2b2ob3o$5b3obobo2bob3o3bob2o2bobo2b2obo3b3obo 2bobob3o$8b4obobo2b2o2bobob2obob2obobo2b2o2bobob4o$5b4o2b3o2bobo2b2ob 2o2bobo2b2ob2o2bobo2b3o2b4o$5b2o2b2o2b3obo2b2ob3o2b3o2b3ob2o2bob3o2b2o 2b2o$9b4obo2bob2o5b2obob2o5b2obo2bob4o$8b2o2bob6o2b2o2bo5bo2b2o2b6obo 2b2o$9b2ob2obo2bo2b5obobobob5o2bo2bob2ob2o$9b5ob2ob3obo3bob3obo3bob3ob 2ob5o$11bo2b2obob3o3bo2bobo2bo3b3obob2o2bo$14bob2obo2b5o2bo2b5o2bob2ob o$13b2obob2obobo2bob3obo2bobob2obob2o$13b2ob2ob3obob2o2bo2b2obob3ob2ob 2o$17b2obob2o2bo2bo2bo2b2obob2o$17bob2obobo2b2ob2o2bobob2obo$18b2ob3ob 2ob3ob2ob3ob2o$23b5obob5o$25bo7bo! 振荡子由于 LifeFind 找不了周期稍大一点的振荡子，我其实也没有多少新的发现。 随便倒一锅汤，一般都能看到一个周期8的转圈圈。虽然周期有点大，但个头很小，LifeFind 一搜就出来了： LifeFind[4, 4, 8, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True] x = 4, y = 4, rule = 3457/357/5 3.$3A$B2A$.CD! 原本这就是已知的周期最小的振荡子了。现在有了 LifeFind，可以轻松找到周期5的振荡子（比搜生命游戏里同样大小的振荡子快多了，大概因为是 Generations？）： LifeFind[4, 8, 5, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True] x = 8, y = 4, rule = 3457/357/5 .D.D.AB$4AC2AC$B2A.B2AD$.CD2.A! 稍大一点的： LifeFind[4, 8, 5, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True] x = 7, y = 7, rule = 3457/357/5 4.CB$3.D3A$4.2A$.BADBA$C2AC$D2AB$2.A! 加点对称性条件，能搜到更漂亮的： LifeFind[10, 10, 5, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True, "Symmetry" -&gt; "C4"] x = 10, y = 10, rule = 3457/357/5 4.D$3.B3A$3.C2AB$.AB.DA.CB$.3A2.D2AD$D2AD2.3A$.BC.AD.BA$3.B2AC$3.3AB$ 5.D! 有一个长得和它很像的周期6： LifeFind[10, 10, 6, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True, "Symmetry" -&gt; "C4"] x = 10, y = 10, rule = 3457/357/5 4.BA$3.C2A$3.D2A$3.BCDBDC$3AD2.C2AB$B2AC2.D3A$.CDBDCB$4.2AD$4.2AC$4.AB ! 以上这几个振荡子好像都是周期8转圈圈的变种。当然也有不是的，比如这个两个细胞渐渐消失的振荡子： LifeFind[8, 8, 5, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True, "Symmetry" -&gt; "D4X"] x = 8, y = 8, rule = 3457/357/5 6b2o$2b2o2b2o$bob3o$b2o2bo$2bo2b2o$2b3obo$2o2b2o$2o! 还有很多别的振荡子。但由于最小的周期也有5，搜索较大的振荡子比较困难。这里就不贴出更多结果了。 飞船目前找到的飞船速度还是只有 c/2。不过飞船特别多，也不难搜。 懒得画背景会动的图了。 以下是几次输入 LifeFind[16, 16, 4, 2, 0, "Rule" -&gt; "3457/357/5", "Changing" -&gt; True, "Symmetry" -&gt; "D2|"] 得到的结果： x = 16, y = 16, rule = 3457/357/5 2$3.D.D4.D.D$.DCBC6.CBCD$.B3A.D2BD.3AB$D.ADABA2CABADA.D$BCABAB4ABABACB $5A2C2A2C5A$3A2.6A2.3A$6.A2CA$4.CDA2CADC$4.AB4ABA$4.3A2.3A$5.A4.A! x = 16, y = 16, rule = 3457/357/5 3.D.2A2.2A.D$2.CDC6ACDC$.D.10A.D$CBD4A2.4ADBC$2ABC.BC2ACB.CB2A$.6A2.6A $.2A.AD4ADA.2A$3.4A2.4A$5.AC2ACA$2.DCD2A2.2ADCD$D.BAB2A2D2ABAB.D$BC2A 2.A2BA2.2ACB$3A3.4A3.3A$3A4.2A4.3A! x = 16, y = 16, rule = 3457/357/5 $2.2D8.2D$.CBC.CD2.DC.CBC$.3ADB.2A.BD3A$CDA.A.A2BA.A.ADC$ABACA.4A.ACAB A$5A6.5A$.A.2A6.2A.A$.DC.D6.D.CD$.BACB2.2B2.BCAB$2.3AD.2C.D3A$2.3ABC2A CB3A$3.2A.4A.2A! x = 16, y = 16, rule = 3457/357/5 5.BC2.CB$5.2A2.2A$6.4A$DC4.4A4.CD$BAD2BDA2.AD2BDAB$.AB3CA2BA3CBA$.14A$ 2.A.A.4A.A.A$2.DC.D4.D.CD$.CBACB4.BCABC$.2A.A.C2.C.A.2A$CDACACA2DACACA DC$AB5A2B5ABA$3A.A.4A.A.3A$.A5.2A5.A! 也能搜胖乎乎圆滚滚的飞船（不过毕竟是飞船，没法很圆，像个大虫子）： LifeFind[47, 47, 2, 1, 0, "Rule" -&gt; "3457/357/5", "Symmetry" -&gt; "D2|", "KnownCells" -&gt; &#123;DiskMatrix[23] _&#125;] x = 47, y = 47, rule = 3457/357/5 2$18.D9.D$16.D.BC7.CB.D$8.DC5.CBC2A.D3.D.2ACBC5.CD$8.BADC.CD3A.ACB3.BC A.3ADC.CDAB$9.ABA.ABA3.3A3.3A3.ABA.ABA$9.3A.3A3.3A3.3A3.3A.3A$10.A3.A 2.D11.D2.A3.A$3.DC.DCD3.DCD.CB.CD5.DC.BC.DCD3.DCD.CD$3.BACBABC.CBABCA. CABC3.CBAC.ACBABC.CBABCAB$4.3AD.AD2A.3ADA.2A3.2A.AD3A.2ADA.D3A$4.3ABCA BA.D3ABA.ADC.CDA.AB3AD.ABACB3A$5.2A.4ACB2A.2A.ABA.ABA.2A.2ABC4A.2A$8.D .ADA2.DC2A.3A.3A.2ACD2.ADA.D$6.D.BCABAC.BADAD3A.3ADADAB.CABACB.D$.DC.D CBC.A.3AD.ABABADA.ADABABA.D3A.A.CBCD.CD$.BACBA.ADACA2.BC5ABA.AB5ACB2.A CADA.ABCAB$2.3ADCAB3ADC.ADA2.3A.3A2.ADA.CD3ABACD3A$2.3AB4A.ABADABA.CDA 3.ADC.ABADABA.4AB3A$3.2A6.3AB3ACAB5.BAC3AB3A6.2A$6.D.D2.4A2.3A7.3A2.4A 2.D.D$3.CDCBCB.D4.CD.2A7.2A.DC4.D.BCBCDC$2.CAB3A.CBCDCDAB.A.C5.C.A.BAD CDCBC.3ABAC$CDA.A2DAD3ABAB.ACACADC.CDACACA.BAB3ADA2DA.ADC$ABA.A2BABA3. 2AC5ABA.AB5AC2A3.ABA2BA.ABA$3A.6AD.D.3A.A.3A.3A.A.3A.D.D6A.3A$.A3.2A2. AB.B.2A.D3.A3.A3.D.2A.B.BA2.2A3.A$4.C.A.C.ACACADCB2.D5.D2.BCDACACA.C.A .C$2.CDACACAD5ABA.CDBC3.CBDC.AB5ADACACADC$2.AB5ABA.A.3A.AB2A3.2ABA.3A. A.AB5ABA$2.3A.A.2A.D3.A2.3A5.3A2.A3.D.2A.A.3A$3.A3.C.ACBC3.DC3A5.3ACD 3.CBCA.C3.A$5.CDAC4A2.CBA4.CDC4.ABC2.4ACADC$5.AB5A3.2A3.CDABADC3.2A3. 5ABA$5.3A.A.AC.CA.D.CABDADBAC.D.AC.CA.A.3A$6.A3.CDADA2.BDADABABADADB2. ADADC3.A$10.ABABA2CABAB5ABABA2CABABA$10.3A.8A3.8A.3A$11.A.D4A11.4AD.A$ 12.CB.D5.D3.D5.D.BC$12.2ACB3.D.BC.CB.D3.BC2A$13.3A3.BC2A.2ACB3.3A$13. 3A3.3A3.3A3.3A$19.3A3.3A!]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亚美尼亚的 Ashugh 和 Gusan]]></title>
    <url>%2F2018%2F12%2F24%2F%E4%BA%9A%E7%BE%8E%E5%B0%BC%E4%BA%9A%E7%9A%84-Ashugh-%E5%92%8C-Gusan%2F</url>
    <content type="text"><![CDATA[我常常在 YouTube 上找亚美尼亚歌曲来听。听得到了，就会经常看到这两个词：Ashugh 和 Gusan。一开头我还以为这是亚美尼亚的常见人名；查了一下之后，发现并非如此。 我完全不懂亚美尼亚语，俄语也是刚看懂字母表的水平，对亚美尼亚文化也并不了解。这篇文章里可能会有不少奇奇怪怪的误解。若是发现由错误的地方，欢迎指正。 Ashugh（աշուղ）和 Gusan（գուսան）这两个词，指的都是亚美尼亚传统的音乐家：他们是诗人，是歌手，也是作曲家。 Ashugh 是吟游诗人。他们从城市走到城市，从村庄走到村庄，以不同的语言即兴创作。与他们相伴的只有自己的乐器：可能是萨兹琴（սազ，saz），塔尔琴（թառ，tar），也可能是卡曼恰（քամանչա，kamancha）。他们的创作题材多种多样，其中最常见的是爱情。事实上，ashugh 这个词正是来自阿拉伯语 عَاشِق‎ (ʿāšiq)，意思好像是恋人。 Ashugh 并非亚美尼亚独有。它在格鲁吉亚语里叫 აშუღი（ašuɣi），在阿塞拜疆语里叫 aşıq，在土耳其语里叫 aşık。这一传统可能诞生于土耳其，在17世纪传入亚美尼亚。那时的亚美尼亚已经被奥斯曼土耳其和波斯瓜分。于是，亚美尼亚的 ashugh 音乐不可避免地染上中东的色彩。以上提到的三种乐器都来源于波斯或者土耳其。 中东的影响还体现在诗歌的署名方式上：他们常常会在诗歌的最后一段提到自己的名字。于是，只要诗歌能传唱下去，人们就不会忘记作者的名字。这种操作也出现在中东的其它诗歌体裁当中。 亚美尼亚的众多 ashugh 中，最杰出、最有传奇色彩的一位是 Sayat-Nova（Սայաթ-Նովա，1712 - 1795）。他是帕拉贾诺夫导演的苏联电影《石榴的颜色》的男主角。Sayat-Nova 原名 Harutyun Sayatyan（Հարություն Սայադյան）。他出生于第比利斯，曾在格鲁吉亚的王宫中当过宫廷乐师，因与安娜公主相恋而被放逐，最后在亚美尼亚的一家修道院度过余生。他留下的音乐作品以亚美尼亚语、格鲁吉亚语、阿塞拜疆语等多种语言写成。其称号 Sayat-Nova 来自波斯语，是“歌王”的意思。 ​与 ashugh 相比，gusan 的中东色彩要淡一些。这个词的历史也比 ashugh 要长得多。早在五世纪时，亚美尼亚的历史学家 Movses Khorenatsi（Մովսես Խորենացի）就有了关于 gusan 的记录。不过我没弄明白它的含义。好像几种不同的传统音乐家，从宫廷乐师到民间的吟游诗人，都被称为 gusan。 现代的 gusan 艺术的奠基人是十九世纪的亚美尼亚音乐家 Gusan Sheram（Գուսան Շերամ，1857 - 1938）。他原名 Grigor Talian（Գրիքոր Թալյան），艺名 Sheram 在亚美尼亚语里是“蚕”的意思。他从小接受的是 ashugh 的训练。从这里开始，ashugh 和 gusan 这两个词就有点纠缠不清了。 在当今的亚美尼亚语中，ashugh 和 gusan 基本上已经是同义词，其中 gusan 这个词比 ashugh 要更加常用。一些传统的 ashugh，比如 Jivani（Ջիվանի，1846 - 1909），有时也被称为 gusan。一些现代的 gusan，比如说 Gusan Ashot（Գուսան Աշոտ，1907 - 1989），也会把自己的名字放在歌词中。不过，,在一些亚美尼亚人看来，ashugh 和 gusan 还是有一点区别：gusan 经常会在乐团中演出，而 ashugh 永远是孤独的，身边只有自己心爱的萨兹琴，塔尔琴，或者卡曼恰。 参考资料： Ашуги About Armenian ashugh tradition 维基百科]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命游戏搜索程序汇总]]></title>
    <url>%2F2018%2F08%2F10%2F%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%90%9C%E7%B4%A2%E7%A8%8B%E5%BA%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[名称 作者 搜索方式 编程语言 平台 网址 备注 apgsearch (2.0 以上版本) Adam P. Goucher 汤 C++ 64 位 Linux GitLab apgsearch (1.x 版) Adam P. Goucher 汤 Python Golly 脚本 Catagolue ikpx Adam P. Goucher SAT 问题 Python 跨平台 GitLab 仅支持生命游戏 Logic Life Search Oscar Cunningham SAT 问题 Python 号称跨平台（Windows 下需要 Cygwin） GitHub 需要自备 SAT Solver gfind David Eppstein 见相关论文 C 跨平台 代码 专搜飞船 gsearch David Eppstein 给定范围里的暴力搜索 C 跨平台 代码 很慢 ofind David Eppstein 类似于gfind C 跨平台 代码 专搜振荡子 lifesrc David Bell Dean Hickerson 发明的算法 C 跨平台 代码 JavaLifeSearch Karel Suhajda 同 lifesrc Java 跨平台 帖子 lifesrc 的 Java 版 WinLifeSearch Jason Summers 同 lifesrc C Windows 官网 lifesrc 的 Windows（图形界面）版 catalyst) Gabriel Nivasch 静物与给定图样的反应 C++ 跨平台 代码 专搜催化 Random Agar Gabriel Nivasch 类似于汤 C++ 跨平台 代码 专搜琼脂 CatForce simsim314 暴力搜索？ C++ 跨平台 Github 专搜催化 yfind strake SMT Haskell 跨平台 Github 需要 Z3 zfind zdr 不清楚 C++ 跨平台 Github life slice ship search Andrew Wade 见其 Readme Rust Linux GitLab]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wolfram|Alpha 计算时显示的元胞自动机（二）]]></title>
    <url>%2F2018%2F08%2F09%2FWolfram-Alpha-%E8%AE%A1%E7%AE%97%E6%97%B6%E6%98%BE%E7%A4%BA%E7%9A%84%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Wolfram|Alpha 计算时显示的元胞自动机（一） Wolfram|Alpha 计算时显示的元胞自动机（三） 这篇文章没什么内容，只是列举一些我们找到的图样。 原本发在简书时是我自己用 Mathematica 画得的图，转发到这里的时候全部换成 LifeViewer。 对随机的开局，这个元胞自动机也有可能会稳定下来，但大部分情况下会保持一种乱糟糟的状态，缓慢地无限增长。按照 Wolfram 对元胞自动机的分类，它应该算是 Chaotic 的。 静物静物有很多。由于 3457/357/5 规则的静物在 B357/S3457 规则里也是静物，因此可以用《用 Mathematica 搜索生命游戏中的静物（二）》里的代码来搜索。这样可以找到很大的静物，比如说： x = 64, y = 64, rule = 3457/357/5 10.2A3.2A7.2A2.2A4.2A6.2A2.2A.A6.2A.2A$.2A2.2A3.2A3.2A7.2A2.2A2.3A.A 5.5A.4A.A2.3A.3A$.2A2.2A4.A.2A.2A.2A.2A6.3A.2A.A.2A.A2.A3.2A.4A.A3.2A $2A.2A.A.6A4.2A.2A2.4A2.2A2.3A.2A2.2A2.5A2.3A.A.A$.A.A.4A.A2.3A.A6.2A .A.4A2.4A3.4A.2A2.3A2.3A.3A$A.3A.3A5.A.2A7.3A.A.A7.A.5A3.2A.4A.A3.2A$ 3A.A.A.7A.A4.2A2.3A.3A3.6A.A.2A3.3A3.A.3A2.2A$.A.A3.A.A2.A2.2A3.A.3A 5.A3.A.2A3.2A2.2A4.A2.2A.A.2A2.A$.2A.2A.A.2A.A.A.A.3A.2A2.A.3A3.2A4.A .A2.A3.2A3.3A2.2A.A$3A2.3A.A.A.A.5A5.3A.3A.2A2.4A.2A.A2.A.2A5.3A2.2A$ A2.A2.A3.2A2.A3.A2.2A.2A4.A3.3A.A.A.A.A.3A.2A2.4A3.A.A$.4A2.A.2A2.5A. A.2A.A5.3A2.2A.3A.2A.A2.2A.A.A.A.2A.3A$2A2.2A.2A.3A.A.A.A.A2.2A2.2A.A .2A2.2A3.2A.A2.2A.5A2.A3.A$A4.4A.A.2A2.2A2.4A.4A2.A.A.A2.A2.2A.2A.A4. A2.3A3.A$.A2.A.A4.A.A.A2.4A.2A3.A3.9A.A.A2.A5.3A.2A.3A$6A.2A.3A2.4A3. A.4A.3A3.A.A.2A.A.5A3.3A.A.2A.2A$A.2A3.3A.A.3A2.A.A2.2A2.A2.A.A3.A.A 2.2A.A4.A.A3.3A.A.A$.A2.2A3.A.2A.2A.5A.2A.2A2.A.4A.A2.A2.3A2.A.2A2.A 2.2A3.A$2A2.A.2A.A.2A.A2.2A2.A3.A.2A.2A.2A2.A.5A.4A3.5A.2A.2A$3A.A.5A .2A2.A.A.2A3.A.4A.8A2.A2.2A.A3.A.A.2A.A.A$.A2.2A3.A3.2A.2A2.A3.3A3.A. A2.2A.A.2A2.A2.A5.A2.A3.2A$.A2.2A2.2A3.4A.7A.4A3.2A3.2A2.2A.A2.3A3.5A .3A$2A.2A.3A3.2A2.A.2A.2A.A2.3A.2A.A3.2A2.4A.4A4.A.2A2.A.A$A2.2A.A3.A 2.A.3A2.A3.5A2.2A.2A3.2A.8A4.A.A3.A.2A$.A3.3A.3A2.A.A2.A2.3A.6A3.5A2. A.5A2.A.A.A.A.4A$3A.A2.A.A.2A.2A2.2A.3A2.A.A.2A3.A.A3.A2.A.2A2.3A.A.A .2A2.A$.A.2A3.2A3.A.2A.A2.6A3.A.2A.3A.2A.8A.2A2.A.A.A.3A$.2A2.3A.3A2. 2A2.4A.A.7A.7A2.2A.A2.A5.2A2.2A2.A$3A2.A.A.A.2A.2A2.2A.3A2.A2.A6.4A2. 4A.2A6.3A2.A2.A$.A.2A2.2A2.A2.A4.A3.A2.2A.2A.2A3.2A6.3A3.2A2.A.4A.2A$ .A.2A.A2.6A3.A2.2A.2A2.A2.12A4.A3.4A.A2.A2.A$3A.6A.A.A4.2A.2A2.4A2.A 2.2A2.A.6A.A.2A.A2.A2.2A2.A$.2A.A4.A2.A.A2.5A.A2.A2.2A.2A2.2A2.A.A2. 5A5.2A.2A.3A$.A.3A2.4A.A.A2.A3.2A.A3.4A2.A2.5A.2A3.A4.2A.A.3A.A$3A.2A 2.2A2.A2.2A2.4A.A.3A2.A2.6A.A.A2.3A6.2A3.A.A$A4.2A.3A2.3A.2A2.A3.A.A 2.2A3.A4.A.2A2.2A3.A2.A.A.3A.2A$.2A.A2.A2.A.2A.A.2A3.A.3A2.2A4.2A2.A 2.3A.9A.3A2.3A$2A.7A.A2.A6.2A.A2.2A.A3.3A2.2A4.A.A.A.A.2A.3A.A$2A.A. 2A.2A2.A2.2A.6A3.A3.2A2.A.2A2.2A2.2A2.A3.A.2A.6A$2.2A3.A3.3A.3A.2A5. 4A.3A4.7A.A.A.A2.2A2.A.A2.2A$2.4A2.A.3A2.3A.A3.4A.A.A3.3A2.A.A3.8A.4A .2A.A$.2A2.2A.2A.A2.A3.2A3.3A2.2A.A2.4A2.A3.A.A4.A.2A2.A.A2.A$A2.2A2. A5.6A5.5A.A.A.2A2.2A4.2A3.A.A.2A.2A.5A$4A.A2.A.3A.A.2A.A2.A2.A.A3.A.A 2.3A.3A.A.7A2.A2.3A.2A$.A2.2A.3A.A.2A3.6A3.3A.6A.A.A.4A.2A2.A2.A2.A4. A$.2A3.A2.A.2A.3A2.A2.A4.2A.A5.A2.4A10.2A.5A2.A$2A.2A2.A.A.A3.3A6.A3. A.6A2.2A3.3A.2A5.A2.A.2A.2A$2A.A.2A.A.4A3.2A4.6A.A2.A2.2A2.4A.2A.3A2. A.A2.A3.A$.A.2A.A2.A2.2A.2A.3A2.2A.A.2A6.2A2.2A.3A.2A.7A.A3.A$.2A.2A 2.2A3.3A.2A.3A3.3A.6A.2A.A2.3A.A.A3.A2.4A.3A$2A.2A.2A.2A2.A2.2A.A.4A 2.A.2A.A.A.2A.A.A2.2A.A.4A.2A.A2.2A.A$.A.A.2A.2A2.3A5.4A.3A.2A2.A3.2A 2.2A2.2A.2A2.A2.A.2A3.A$.A.2A2.2A.A.2A.2A.2A.A.A.A.A.A.A.2A.A.2A2.A.A 2.A.A.2A2.A.3A.A$3A.4A.2A2.A.3A.A.4A.A.2A.4A.2A2.8A.A2.A.2A.A2.3A$A. 2A2.A4.A2.2A2.3A.A.3A2.A.4A.2A2.2A2.A3.7A.3A3.A$.A2.A.A4.2A.A3.A5.6A. 2A.A.A4.A.2A.A3.2A5.3A.3A$2A2.3A.2A.A2.4A5.A3.A.A.4A.A4.7A.4A4.A2.2A. A$A.2A.A2.8A.2A2.3A2.2A2.2A2.2A.2A3.A2.A.2A.A2.A.2A3.A.A$.4A.A3.A3.A 2.2A2.2A.6A.A.2A.A.5A.2A2.2A.4A.A.A.A.2A$3.A.A.2A.2A3.A2.2A.3A.A3.A. 3A.3A.2A.A2.4A.A.2A.7A.A$6.A.3A3.3A3.A.A5.3A11.A2.A.A.3A4.3A2.2A$2A2. 2A5.A2.2A.2A2.2A4.A3.A5.2A.3A.2A5.A4.A.A.2A$2A2.3A.6A.A.A.2A.2A.9A.4A .2A.A.4A.3A2.7A$6.2A.2A2.2A3.2A.2A.2A2.2A2.2A.2A7.2A2.2A.2A2.2A2.A! 因此我无法，也没有必要去列举找到的所有静物。 最常见的静物是方块： x = 2, y = 2, rule = 3457/357/5 2A$2A! 或者两个方块相连： x = 4, y = 3, rule = 3457/357/5 2.2A$4A$2A! 或者三个： x = 5, y = 4, rule = 3457/357/5 2.2A$2.2A$2A.2A$2A.2A! 或者更多…… 最常见的一个不是由多个方块组成的静物是这个： x = 5, y = 5, rule = 3457/357/5 2.2A$2.2A$2A.2A$3A.A$2.2A! 也有一些稍大一点的对称的静物，比如说： x = 10, y = 10, rule = 3457/357/5 4.2A$2.6A$.A.A2.A.A$.2A.2A.2A$2A.A2.A.2A$2A.A2.A.2A$.2A.2A.2A$.A.A2.A .A$2.6A$4.2A! 振荡子由于一个活的细胞至少要过4代才能死掉，因此不存在周期小于5的振荡子。 目前发现的振荡子不多，而且没法转换成 Life-like 的情形来搜索。 最常见的振荡子是这个周期8的转圈圈： x = 3, y = 3, rule = 3457/357/5 3A$B2A$.CD! 第二常见的是这个周期26的梭： x = 5, y = 5, rule = 3457/357/5 2.A$.2AB$3ADC$.2AB$2.A! 然后还找到这个周期15的： x = 9, y = 9, rule = 3457/357/5 3.3A$3.3A$3.ACA$3A.A.3A$2ACA.AC2A$3A.A.3A$3.ACA$3.3A$3.3A! 以及这个周期18的： x = 5, y = 5, rule = 3457/357/5 2.B$3AC$2ADAB$3AC$2.B! 在我以为再也发现不了什么新的振荡子的时候，Hunting 发现，两个梭相撞有时也能得到新的振荡子，比如说： x = 13, y = 6, rule = 3457/357/5 2.A$.B2A6.A$CD3A4.2AB$.B2A4.3ADC$2.A6.2AB$10.A! 后来，ConwayLife.com 上的 danny 还发现了一个周期 10 的振荡子： x = 9, y = 9, rule = 3457/357/5 4.DC$4.3A$3.2AB.A$2.A.A.BAC$D3A.3AD$CAB.A.A$.A.B2A$2.3A$3.CD! 在我给 LifeFind 添加上搜索 Generations 的规则的功能之前，找到的振荡子就这么多。 飞船已经找到好几架飞船，但速度都是c/2。 最常见的飞船是这个周期2的： x = 5, y = 4, rule = 3457/357/5 .CA$DB3A$2.C2A$.DB2A! 以及这个，也是周期2： x = 5, y = 6, rule = 3457/357/5 .CA$DB3A$2.C2A$2.C2A$DB3A$.CA! 这个不知道该算一架飞船还是两架： x = 5, y = 9, rule = 3457/357/5 .CA$DB3A$2.C2A$.DB2A2$.DB2A$2.C2A$DB3A$.CA! 别的飞船的头部都和上面这些飞船一样，只是尾部有些区别。 比如说这个周期4的： x = 8, y = 6, rule = 3457/357/5 4.CA$.BADB3A$BC2A.C2A$BC2A.C2A$.BADB3A$4.CA! 这个也是周期4： x = 9, y = 9, rule = 3457/357/5 5.CA$2.BADB3A$.AC2A.C2A$DB3ADB2A2$DB3ADB2A$.AC2A.C2A$2.BADB3A$5.CA! 还是周期4： x = 9, y = 12, rule = 3457/357/5 5.CA$4.DB3A$3.CA.C2A$.CD2A.C2A$.BD6A$BC2A2DA$BC2A2DA$.BD6A$.CD2A.C2A$ 3.CA.C2A$4.DB3A$5.CA! 最后这个是周期8： x = 8, y = 10, rule = 3457/357/5 4.CA$3.DB3A$2.CA.C2A$DABA.C2A$8A$.2B2DA$ABA2DA$AC6A$BA.A.C2A$4.DB2A! 在给 LifeFind 添加上搜索 Generations 的规则的功能之前，找到的飞船就这些。 PufferPuffer 这个词不知道怎么翻译……河豚？蒸汽机车？喷气者？ 目前发现的好看的 puffer 只有两个。 这个周期是28： x = 8, y = 18, rule = 3457/357/5 4.CA$3.DB3A$2.CA.C2A$DABA.C2A$.AB5A$2.A2DA$2.A2DA$.7A$2ADA.C2A$2ADA.C 2A$.7A$2.A2DA$2.A2DA$.AB5A$DABA.C2A$2.CA.C2A$3.DB3A$4.CA! 这个周期是64： x = 13, y = 24, rule = 3457/357/5 9.CA$8.DB3A$3.DCA.CA.C2A$2.C.5A.C2A$2.DB3AC5A$2.C2.2BA2DA$3.4AB2DA$.D A.9A$2.2A.A2DA.C2A$.2AC2A2DA.C2A$D2A2C8A$D2A2CA2C2DA$D2A2CA2C2DA$D2A 2C8A$.2AC2A2DA.C2A$2.2A.A2DA.C2A$.DA.9A$3.4AB2DA$2.C2.2BA2DA$2.DB3AC 5A$2.C.5A.C2A$3.DCA.CA.C2A$8.DB3A$9.CA! 还有别的 puffer，但后面喷出的东西很不规则，而且无法稳定下来，并不好看。它们的速度基本上都是 c/2，“头部”也类似于上面的这些飞船和 puffer。目前发现的唯一例外是一个 (2,14)c/46 的斜 puffer（也就是说，每46代向下移动2格，向右移动14格）： x = 4, y = 5, rule = 3457/357/5 2.BA$.C2A$D.CA$.3A$.2A! 复制子？除了以上这些东西之外，还有一个比较有趣的图样。它差点就能成为一个复制子了，不过复制了十几代之后就乱了。 x = 5, y = 5, rule = 3457/357/5 2.A$.BAB$2AC2A$.3A$.3A!]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维基百科的新年图标]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E7%9A%84%E6%96%B0%E5%B9%B4%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[第一次发现俄语维基百科的新年图标是在2013年1月3日。当时我在果壳的维基百科小组发了这么一个帖子：《俄文维基的新图标》。帖子中的图片是外链，现在已看不到原来的图标，只记得那是维基的球上冻了一层冰块（参见下文中2015年塞尔维亚语维基的图标）。我还不明白这个图标的意义，但mraandtux在回帖中猜测： 冬季特别Logo（恭喜俄文维基“渡劫”成功）？ 燃玉的猜测则是： 难道是抗议某法案？ 我不懂俄语，很少去俄语维基，不知道它是什么时候恢复到了原本的图标。一年过去了，我发现又换上了新的图标。这次我觉得它应该是新年图标，并在果壳发了这么一个帖子：《俄文维基的新年图标》。发帖日期正好是2014年1月1日，帖子中保留了当时的图标： 又过了一年，我不知为什么又觉得它应该是冬天的图标，可能是因为图标中的元素都与冬季有关。在2015年1月3日，我发了这么一个帖子：《冬天的维基百科图标》。这次俄语维基的图标变成了这样： 除了俄语，我又发现亚美尼亚语、格鲁吉亚语、斯洛伐克语、塞尔维亚语四种语言的维基百科也换了图标： 为了弄清楚这到底是冬季图标还是新年图标，我在2016年新年来临之前就开始关注俄语维基，发现他们对十几种图标进行了投票，而且用的词是Новогодний логотип（新年图标）。投票的结果是沿用了2015年的图标。这一切记录在我发表于2015年12月30日的《2016年维基百科的新年图标》一帖中。 落选的图标中，我觉得最萌的是这两个（这鸟是红腹灰雀，俄语叫снегирь，这词和雪снег同源）： 一天之后（12月31日），另外两种语言也换上了新图标。格鲁吉亚语沿用了上一年的图标，亚美尼亚语则加了个硕大的2016。 《2017年的新年图标》一帖发表于2017年1月2日。这一词好像亚美尼亚语维基也没有换图标，俄语维基则继续沿用了上一年的图标。 格鲁吉亚语的比较萌： 2018年的帖子《2018年的新年图标》最早发表于2017年12月29日。此时已有三种语言的维基百科换上了新图标。 亚美尼亚语维基百科沿用了2015年的设计，改了下帽子的大小和字体： 克罗地亚语维基百科用的是2015年格鲁吉亚语维基百科的设计（不知道谁抄的谁）： 马其顿语维基百科用的是2015年塞尔维亚语维基百科的设计（也不知道谁抄的谁，维基百科的名字在这两种语言里是一模一样的，只有斜体的п的写法不一样。）： 到了12月31日，格鲁吉亚维基百科也换上了新图标，沿用了上一年的图标，好像没改： 俄语维基的新年图标则姗姗来迟。在其投票页面中，我看到了下面候选图标： 有几个上面是“袓”字而不是“维”字，包括马其顿语维基百科采用的那个，看来历史是相当悠久了。其中我最喜欢的还是红腹灰雀的那个。 到了1月1日，俄语维基终于换上了新年图标： 到了2019年的新年，果壳网大概已经不在了吧。不知道那时维基百科的新年图标又会变成怎么样。 更新：2019年的新年时，果壳网果然已经不在了，上面的那些帖子已经全部消失。我只能把新年图标发到知乎想法。 在2018年12月29日，最早换上新年图标的竟然是俄语维基： 然后是格鲁吉亚语： 乌克兰语也短暂换上了新年图标，但在新年之前就被撤下了： 然后是亚美尼亚语、克罗地亚语和塞尔维亚语：]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
        <tag>维基百科</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wolfram|Alpha 计算时显示的元胞自动机（一）]]></title>
    <url>%2F2018%2F07%2F09%2FWolfram-Alpha-%E8%AE%A1%E7%AE%97%E6%97%B6%E6%98%BE%E7%A4%BA%E7%9A%84%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Wolfram|Alpha 计算时显示的元胞自动机（二） Wolfram|Alpha 计算时显示的元胞自动机（三） 果壳网已完，不知道我发过的帖子什么时候会消失，于是我要把它们搬到简书。 （注：在搬到新的博客的时候，这个帖子，以及整个果壳小组，都已经消失了。） 但这篇不是搬运，只是想说一下这个帖子背后的故事……以及代码。 Wolfram|Alpha 在显示计算或查询的结果之前，往往需要思考一番。几年前，它在思考过程的中会显示一个漂亮的图案。现在那个图案已经变成了一个无聊的 COMPUTING...，不过网上还是留下了一点痕迹，比如说知乎的这个问题：Wolfram|Alpha在搜索时出现的图案有什么含义?和 StackOverflow 的这个问题：What is the cellular automaton shown as loading screen on Wolfram Alpha? 我也一直想知道这是什么图案。它显然是一个元胞自动机，大小不同的点表示不同的状态；而且状态不止一种，因此肯定不是生命游戏，也不是生命游戏家族（Life-like）的规则。但它思考的速度太快，我总是来不及看清它到底是什么规则。 直到有一天，我在人人网上——当时人人网还不是直播平台——看到这么一个截图： 不知那位同学用的是什么截图工具，能够截得这么清晰，而且没有掉帧。总之，有了这个截图，我就能把它导入到 Mathematica，一帧一帧地慢慢看……并不能看出它是什么规则，甚至不能看清它有几种状态——最小的两种点个头差不多，只是颜色的深浅稍稍有点区别，肉眼不容易看清。不过我还是看出了一点规律：稍大一点的点会变得越来越大，直到爆掉，消失。而且，我还看到了这个一个振荡子： 除了 Life-like 的规则，还有什么规则？我在 Golly （最好的元胞自动机模拟器，没有之一）的帮助里看到了一类叫 Generations 的规则，觉得和这个有点像。不过那里给的几个 Generations 规则的例子和 Wolfram|Alpha 的这个元胞自动机都对不上。 Generations 的规则和 Life-like 的规则类似，每个细胞也有死活两种状态，下一回合的状态由这一回合的死活、以及与它相邻的活细胞的个数来决定。与 Life-like 不同的是，活细胞在临死之前，还能苟延残喘几个回合，但死亡的过程并不受周围的细胞影响，最终也无法摆脱死亡的命运。 比如说，那个叫 Frogs 的元胞自动机，规则按 Golly 的写法是 12/34/3。最后这个数字 3 表示它有三种状态：一个是死，一个是活，一个是正在死亡。也就是说，一个活细胞在临死前只能多活一个回合。前面的 12 说的是：一个活细胞要想继续好好活着，八个邻居里活细胞的个数必须是1或者2； 34 的意思则是：一个已经死掉的细胞要想活过来，周围的活细胞个数必须是3或者4。 Wolfram|Alpha 的元胞自动机应该也是 Generations 一类，但肉眼不容易看出具体是什么规则。不过不要紧，我们还有 Mathematica。直接看不出，我们就把图片二值化了看，拆成一个个连通分支来看，数清了每个点周围的活细胞个数再看。 当年的代码我没有留着。下面的代码都是新写的，用了不少这几年才引进的新函数。 首先当然是导入图片并去掉重复帧。我一开始没发现截图中有重复帧，导致结果很奇怪，还以为它不是 Generations 的规则。 CA = First /@ Split@Import["WolframAlphaCA.gif"]; 先试着把第一帧二值化一下，发现它还有一个框框： Binarize[CA[[1]]] 摘掉黑框再二值化。二值化的阈值不能太低，以免最小的点消失；也不能太高，以免相邻的点连起来。试了好几个数，0.85 是最合适的。 Binarize[ImagePad[#, -BorderDimensions@#], 0.85] &amp;@CA[[1]] 看起来不错。于是我就把每一帧都二值化了。顺手还给它们反个色，以方便下一步处理。 CABinarized = 1 - Binarize[ImagePad[#, -BorderDimensions@#], 0.85] &amp; /@ CA; 现在每个细胞——死细胞不算——是这个图片的一个连通分支。细胞的状态对应于连通分支的大小。于是可以用上 ComponentMeasurements 函数。 先来看看这些细胞的位置。还是先看第一帧，算出所有连通分支的重心，把所有的横坐标和所有的纵坐标分别从小到大排列： Union /@ Transpose[Last /@ ComponentMeasurements[CABinarized[[1]], "Centroid"]] 结果是： &#123;&#123;8.5, 18.5, 28.5, 38.5, 48.5, 58.5, 68.5, 78.5, 88.5, 98.5, 108.5, 118.5, 128.5, 138.5, 148.5, 158.5, 168.5, 178.5, 188.5, 198.5, 208.5, 218.5, 228.5, 238.5, 248.5, 258.5, 268.5, 278.5, 288.5, 358.5, 368.5, 378.5, 388.5, 398.5, 408.5, 418.5, 428.5, 438.5, 448.5, 458.5, 468.5, 478.5, 488.5, 498.5, 508.5, 518.5, 528.5, 538.5, 548.5, 558.5, 568.5, 578.5, 588.5, 598.5, 608.5, 618.5, 628.5, 638.5, 648.5&#125;, &#123;12., 12.2193, 21.5, 22., 31.5, 32., 41.5, 42., 51.5, 52., 61.5, 62., 71.5, 72., 81.5, 82., 91.5, 92., 101.5, 102., 111.5, 112., 121.5, 122., 131.5, 132., 141.5, 142., 151.5, 152., 161.5, 162., 171.5, 172., 181.5, 182., 191.5, 192., 201.5, 202., 211.5, 212., 221.5, 222., 231.5, 232., 241.5, 242., 251.5, 252., 261.5, 262., 271.5, 272., 281.5, 282., 291.5, 292., 301.5, 302., 311.5, 312., 321.5, 322., 331.5, 332., 341.5, 342., 351.5, 352., 361.5, 362., 372.&#125;&#125; 可以看出相邻的两个点之间大概差10个像素，整个图片中的细胞个数是 65 × 37。这里出现了一个很奇怪的 12.2193，是因为最下面一排有一个点只露出了大半。为了避免这种问题，我去掉了最外面的一圈细胞，只取重心的横坐标在 15 和 645 之间，纵坐标在 15 和365 之间的那些连通分支。 然后看连通分支的大小。取了一下 Union，发现图片的每一帧，在去掉了最外面的一圈细胞之后，连通分支的大小都只有 {6, 9, 37, 69} 这么四种： Union[Last /@ ComponentMeasurements[#, "Count", 15 &lt; #Centroid[[1]] &lt; 645 &amp;&amp; 15 &lt; #Centroid[[2]] &lt; 365 &amp;]] &amp; /@ CABinarized 于是这四种不同大小的活细胞和濒死的细胞，再加上死细胞，一共有五种状态。最初的截图里分不太清的两种状态，在这里分别对应 6 和 9。 然后我们可以把这些图片化成代表细胞状态的数组，把 {6, 9, 37, 69} 分别换成 {1, 2, 3, 4}，死细胞还是用 0 表示。 CAArray = SparseArray[ Round[(#[[2, 1]] - &#123;8.5, 12&#125;)/10] -&gt; (#[[2, 2]] /. Thread[&#123;6, 9, 37, 69&#125; -&gt; Range@4]) &amp; /@ ComponentMeasurements[#, &#123;"Centroid", "Count"&#125;, 15 &lt; #Centroid[[1]] &lt; 645 &amp;&amp; 15 &lt; #Centroid[[2]] &lt; 365 &amp;], &#123;63, 35&#125;] &amp; /@ CABinarized; 如果它真的是 Generations 的规则，每个细胞在下一回合的状态就完全由它在这一回合的状态和周围的活细胞的个数来决定。于是来算一算，看看是否如此： Union@Flatten@ BlockMap[&#123;#[[1, 2, 2]], Count[#[[1]], 1, &#123;2&#125;]&#125; -&gt; #[[2, 2, 2]] &amp;, CAArray, &#123;2, 3, 3&#125;, 1] 结果是： &#123;&#123;0, 0&#125; -&gt; 0, &#123;0, 1&#125; -&gt; 0, &#123;0, 2&#125; -&gt; 0, &#123;0, 3&#125; -&gt; 1, &#123;0, 4&#125; -&gt; 0, &#123;0, 5&#125; -&gt; 1, &#123;0, 6&#125; -&gt; 0, &#123;0, 7&#125; -&gt; 1, &#123;0, 8&#125; -&gt; 0, &#123;1, 1&#125; -&gt; 2, &#123;1, 2&#125; -&gt; 2, &#123;1, 3&#125; -&gt; 2, &#123;1, 4&#125; -&gt; 1, &#123;1, 5&#125; -&gt; 1, &#123;1, 6&#125; -&gt; 1, &#123;1, 7&#125; -&gt; 2, &#123;1, 8&#125; -&gt; 1, &#123;1, 9&#125; -&gt; 2, &#123;2, 0&#125; -&gt; 3, &#123;2, 1&#125; -&gt; 3, &#123;2, 2&#125; -&gt; 3, &#123;2, 3&#125; -&gt; 3, &#123;2, 4&#125; -&gt; 3, &#123;2, 5&#125; -&gt; 3, &#123;2, 6&#125; -&gt; 3, &#123;2, 7&#125; -&gt; 3, &#123;2, 8&#125; -&gt; 3, &#123;3, 0&#125; -&gt; 4, &#123;3, 1&#125; -&gt; 4, &#123;3, 2&#125; -&gt; 4, &#123;3, 3&#125; -&gt; 4, &#123;3, 4&#125; -&gt; 4, &#123;3, 5&#125; -&gt; 4, &#123;3, 6&#125; -&gt; 4, &#123;3, 7&#125; -&gt; 4, &#123;3, 8&#125; -&gt; 4, &#123;4, 0&#125; -&gt; 0, &#123;4, 1&#125; -&gt; 0, &#123;4, 2&#125; -&gt; 0, &#123;4, 3&#125; -&gt; 0, &#123;4, 4&#125; -&gt; 0, &#123;4, 5&#125; -&gt; 0, &#123;4, 6&#125; -&gt; 0, &#123;4, 7&#125; -&gt; 0&#125; 结果中的这些数据是 {本回合的状态, 周围的活细胞个数} -&gt; 下一回合的状态。比如说， {1, 3} -&gt; 2 表示某个细胞的状态是 1，也就是一个活细胞；它周围的活细胞个数，包括它本身，是 3；它在下一回合的状态是 2，也就是说刚刚开始死亡。这里同样的键总是对应同样的值，因此每个细胞在下一回合的状态确实由这两个数来决定。 我们还能看出，0 只会变成 0 或 1， 1 只会变成 1 或 2，2 只会变成 3，3 只会变成 4，4 只会死亡。 果然是 Generations。 再来算算这个规则在 Golly 里该怎么写： &#123;Cases[%, (&#123;1, x_&#125; -&gt; 1) :&gt; x - 1], Cases[%, (&#123;0, x_&#125; -&gt; 1) :&gt; x], Max@%[[;; , 1, 1]] + 1&#125; 结果是： &#123;&#123;3, 4, 5, 7&#125;, &#123;3, 5, 7&#125;, 5&#125; 也就是说它在 Golly 里叫做 3457/357/5。 这个规则的含义是：它有五种状态。0 表示死，1 表示活，2、3、4 都是死亡的过程。每个回合每个细胞的变化如下： 0 -&gt; 如果相邻的活细胞个数是3、5、7，则变成 1，否则还是 0 1 -&gt; 如果相邻的活细胞个数是3、4、5、7，则保持是 1，否则变成 2 2 -&gt; 3 3 -&gt; 4 4 -&gt; 0 知道了规则，就可以把它放到 Golly 里，乱搞一通。一旦找到了好玩的东西，还可以用 Mathematica 来制成 GIF。这就是下一篇文章的内容了。]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可以用克罗内克符号来画龙曲线]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%8B%E7%BD%97%E5%86%85%E5%85%8B%E7%AC%A6%E5%8F%B7%E6%9D%A5%E7%94%BB%E9%BE%99%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[原发于果壳 Today I Learned 小组。后面补充的部分来自我在知乎的一个回答。 学过数论的应该都知道勒让德符号。对于一个整数 $a$ 和一个素数 $p$ ，勒让德符号 $\left(\frac{a}{p}\right)$ 定义为：如果 $a \equiv 0 \pmod{p}$，则 $\left(\frac{a}{p}\right) = 0$；否则，如果存在一个整数 $x$ 使得 $x^2 \equiv a \pmod{p}$，则 $\left(\frac{a}{p}\right) = 1$；如果不存在这样的 $x$，则 $\left(\frac{a}{p}\right) = -1$。总之，就是看 $a$ 是不是与某个数的的平方模 $p$ 同余。勒让德符号有很多有趣的性质，在数论里十分有用。 勒让德符号中的 $p$ 只能是素数。雅克比把它推广了一下。对于一个正奇数 $m$，如果它的素因数分解是 $m = p_1 p_2 \cdots p_s$，那么定义雅克比符号 $\left(\frac{n}{m}\right) = \left(\frac{n}{p_1}\right) \left(\frac{n}{p_2}\right) \cdots \left(\frac{n}{p_s}\right)$，其中右边那一串就是勒让德符号。 雅克比符号中的 $m$ 只能是正奇数。于是，克罗内克把它再推广了一下。他首先补上了 $m = -1$ 和 $m = 2$ 的情况。对于 $m = -1$ 的情况，若 $n &lt; 0$，则 $\left(\frac{n}{-1}\right) = -1$；若 $n &gt; 0$，则 $\left(\frac{n}{-1}\right) = 1$；$\left(\frac{0}{-1}\right) = 0$。对于 $m = 2$ 的情况，定义与勒让德符号不同，$n$ 是偶数时，$\left(\frac{n}{2}\right) = 0$；$n \equiv \pm 1 \pmod{8}$ 时，$\left(\frac{n}{2}\right) = 1$；$n \equiv \pm 3 \pmod{8}$ 时，$\left(\frac{n}{2}\right) = -1$。然后，对于一个非 $0$ 的整数 $m$，如果它的素因数分解是 $m = u p_1 p_2 \cdots p_s$，其中 $u$ 是 $\pm 1$，那么定义 $\left(\frac{n}{m}\right) = \left(\frac{n}{u}\right) \left(\frac{n}{p_1}\right) \left(\frac{n}{p_2}\right) \cdots \left(\frac{n}{p_s}\right)$。最后，规定 $\left(\frac{1}{0}\right) = \left(\frac{-1}{0}\right) = 1$，对其它的 $n$ 定义 $\left(\frac{n}{0}\right) = 0$。 这样，对所有整数 $n$、$m$ 我们都定义了一个 $\left(\frac{n}{m}\right)$。这就是克罗内克符号。 上面说了一大堆，都是些数论里的东西，好像与分形没有什么关系…… 我们来看数列 $\left(\frac{-1}{n}\right)$，这里的 $n$ 取正整数。根据定义不难看出，这个数列里边的每一项只能是 1 或者 -1。这是在线整数数列百科（OEIS）里的数列 A034947，开头几项是： 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1 …… 然后，假设你是一只海龟，每次从数列中读取一项；如果是 1，就向左转 90°，向前爬一步；如果是 -1，就向右转 90°，向前爬一步。这样，画出来的图像是什么？ 嗯，就是龙曲线。 再放一张彩图： 顺便说一句，我没学过 Logo 语言，这个海龟我是用 Mathematica 画的，参考了 KTurtle 的图标。 为什么这样能画出龙曲线呢？ 我们先来看获得龙曲线的另一种方法。拿一根纸带，不断地对折，然后把每一处折痕按原来的凹凸展开成直角： 于是，折痕的凹凸就对应于前面海龟作图的左转右转。那么，折痕的规律是什么呢？ 我们把凹记作 1，凸记作 -1。只折一次，得到的当然是： 1 折两次，就会在原来这个 1 的前面和后面各增加一个折痕，前面是 1，后面是 -1（加粗的是原有的折痕）： 1, 1, -1 折三次，会在折两次的基础上，在最前面、最后面和相邻的两个折痕之间，都添上新的折痕。而且新添上的折痕会按 1、-1、1、-1……这样的规律排列。也就是说，相邻的两个新折痕的方向是相反的： 1, 1, -1, 1, 1, -1, -1 类似地，我们可以得到折四次的结果： 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1 这里每一个数列都是后面一个数列的开头。如果我们无限地折下去的话，可以得到一个无限长的数列： 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, … 于是我们不难得到这个数列的一个递推公式： $a(2n) = a(n)$ $a(4n+1) = 1$ $a(4n+3) = -1$ 这和前面的克罗内克符号是什么关系呢？我们只需要看克罗内克符号的两个性质： 由克罗内克符号的定义，有 $\left(\frac{-1}{2}\right) = 1$。因此，$\left(\frac{-1}{2n}\right) = \left(\frac{-1}{2n}\right)$。 数论里的一个重要的结论，有些书把它叫做二次互反律的补充律：对于奇素数 $p$，当 $p \equiv 1 \pmod{4}$ 时，勒让德符号 $\left(\frac{-1}{p}\right) = 1$；当 $p \equiv 3 \pmod{4}$ 时，勒让德符号 $\left(\frac{-1}{p}\right) = -1$。 于是，$\left(\frac{-1}{n}\right)$ 这个数列也满足同样的递推公式。也就是说，它们是同一个数列。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在电脑里发现了一个叫pinyin-database-db的文件]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%9C%A8%E7%94%B5%E8%84%91%E9%87%8C%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%ABpinyin-database-db%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[继续搬运果壳网的旧帖。原帖发表于2013-12-20。我已忘了当时用的是什么输入法，可能是 ibus-pinyin。 在电脑里发现了一个叫pinyin-database.db的文件。好像是拼音输入法的数据库。打开一看，里边的数据从1个字到14个字的词语的拼音和词频。不知道它的词频是从哪里统计来的，不过很有可能从网络上统计的，反正跟我的输入习惯没什么关系。 下面是不同字数的词频最高的十个词语，还挺好玩的： 一字词：的、一、是、我、了、不、在、人、有、他 二字词：所有、论坛、首页、用户、联系、中心、信息、我们、关于、注册 三字词：的位置、用户名、自己的、为什么、上一页、计算机、发表的、下一页、现在的、俱乐部 四字词：（简直就是某些网站的导航条）联系我们、版权所有、有限公司、加入收藏、关于我们、友情链接、广告服务、网站地图、联系方式、发表评论 五字词：我能做什么、人民共和国、经营许可证、加入收藏夹、一体化建设、人大常委会、与我们联系、互联网安全、个人计算机、最近的一个 六字词：（好多有限公司）用户密码修改、发送电子邮件、科技有限公司、股份有限公司、有关法律法规、有限责任公司、技术有限公司、发展有限公司、没有权限访问、不良信息举报 七字词：（有乱七八糟的东西的东西混进来了）中华人民共和国、全国人大常委会、业务经营许可证、意见反馈留言板、有限公司总经理、先进性教育活动、药品监督管理局、乱七八糟的东西、高等教育出版社、我喜欢你的时候 八字词：（在一堆有限公司中夹着一个有一种爱叫做放手）网络科技有限公司、科技发展有限公司、科技股份有限公司、信息科技有限公司、网络技术有限公司、有一种爱叫做放手、电子科技有限公司、数码科技有限公司、保持共产党员先进、质量管理体系认证 九字词：（字数一多这种词就冒出来了，不过有些词好像有点旧了）共产党员先进性教育、国家发展改革委员会、建设社会主义新农村、代表大会常务委员会、贯彻落实科学发展观、社会主义新农村建设、国务院发展研究中心、保持共产党员先进性、全心全意为人民服务、全国计算机等级考试 十字词：中华人民共和国商务部、国家发展和改革委员会、构建社会主义和谐社会、别说我的眼泪你无所谓、中国互联网络信息中心、社会主义市场经济体制、国家工商行政管理总局、质量监督检验检疫总局、社会主义精神文明建设、未成年人思想道德建设 十一字词：（数据库里只收录了7个，有一个还是带错别字的）国家食品药品监督管理局、中国保险监督管理委员会、上海市劳动和社会保障局、以其人之道还治其人之身、学然后知不足教然后知困、学然后知不足教然后之困、明察秋毫之末而不见舆薪 十二字词：（只收录了9个）中国人寿保险股份有限公司、上海市食品药品监督管理局、天有不测风云人有旦夕祸福、只许州官放火不许百姓点灯、鸡犬之声相闻老死不相往来、舍得一身剐敢把皇帝拉下马、拳头上立得人胳膊上走得马、拳头上立得人胳膊上走得路、即以其人之道还治其人之身 十三字词：（一个也没有） 十四字词：（只收录了4个）踏破铁鞋无觅处得来全不费功夫、踏破铁鞋无觅处得来全不费工夫、各人自扫门前雪莫管他家瓦上霜、各人自扫门前雪莫管他人瓦上霜 不过我暂时还没想到能拿这些数据干什么好玩的事情。 另外，可以透露一下，另一个文件里保存着我自己的输入词频的数据库，里边最长的一个词是“挖个坑站进去假装自己是根胡萝卜”。 以下是卅猫的评论： 我喜欢你的时候，有一种爱叫做放手；全心全意为人民服务，别说我的眼泪你无所谓；明察秋毫之末而不见舆薪，舍得一身剐敢把皇帝拉下马。 造句大赛正式开始：一有人在，他不是我的了。所有论坛首页用户联系我们中心，关于注册 信息。为什么现在的俱乐部计算机 自己的用户名上一页发表的，下一页的位置……（下面的不加成分还能编吗）]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[果壳网终于完全地、彻底地、正式地完了]]></title>
    <url>%2F2018%2F07%2F02%2F%E6%9E%9C%E5%A3%B3%E7%BD%91%E7%BB%88%E4%BA%8E%E5%AE%8C%E5%85%A8%E5%9C%B0%E3%80%81%E5%BD%BB%E5%BA%95%E5%9C%B0%E3%80%81%E6%AD%A3%E5%BC%8F%E5%9C%B0%E5%AE%8C%E4%BA%86%2F</url>
    <content type="text"><![CDATA[我会继续把我的一些旧帖搬运到简书。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Mathematica 搜索生命游戏中的静物（二）]]></title>
    <url>%2F2018%2F05%2F13%2F%E7%94%A8-Mathematica-%E6%90%9C%E7%B4%A2%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E9%9D%99%E7%89%A9%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[用 Mathematica 搜索生命游戏中的静物 用 Mathematica 搜索生命游戏中的静物（三） 之前写的那篇《用 Mathematica 搜索生命游戏中的静物》，由于自己写的部分多了一点（虽然关键的一步还是用 Mathematica 自带的 FindPath 函数），特别慢，还特别耗内存。果然对我这种完全不懂算法的人，就应该把所有的事情都交给 Mathematica 才对。 生命游戏里的每个细胞的状态可以看成一个布尔值，一个（大小有限的）图样则可以看成一个由布尔值组成的二维数组。于是，要寻找满足某些条件图样，就相当于要求这些布尔值满足某个方程。于是，这是一个布尔可满足性问题（SAT）。Mathematica 里有个叫 SatisfiabilityInstances 的函数就是干这个的。 我们先把要满足的条件用 Mathematica 代码写出来。 假设我们要找的图样在一个 x 乘 y 的长方形里边，它对应的数组可以用 Array[b, {x, y}] 来表示，这里每个 b[i,j] 表示一个细胞。 静物（Still life）指的是稳定的图样，它要满足下面两个条件： 每个活细胞周围的活细胞个数必须是2或者3， 每个死细胞周围的活细胞个数不能是3。 我们先写一个函数来数一个细胞周围的活细胞个数： NeighborCount[k_, &#123;i_, j_&#125;] := BooleanCountingFunction[&#123;k&#125;, Delete[Catenate[Array[b, &#123;3, 3&#125;, &#123;i, j&#125; - 1]], 5]]; 然后每个细胞要满足的条件可以写成这样： StillLifeCondition[i_, j_] := (b[i, j] &amp;&amp; NeighborCount[&#123;2, 3&#125;, &#123;i, j&#125;]) || (! b[i, j] &amp;&amp; ! NeighborCount[&#123;3&#125;, &#123;i, j&#125;]); 此外，这个图样是有限的，边界之外的细胞总是死的。于是，整个图样要满足的条件可以写成： Array[StillLifeCondition[##] /. b[i_, j_] /; i &lt; 1 || i &gt; x || j &lt; 1 || j &gt; y :&gt; False &amp;, &#123;x, y&#125; + 2, 0, And] 然后我们可以用 SatisfiabilityInstances 函数： SearchStillLife[x_, y_] := ArrayReshape[ SatisfiabilityInstances[ Array[StillLifeCondition[##] /. b[i_, j_] /; i &lt; 1 || i &gt; x || j &lt; 1 || j &gt; y :&gt; False &amp;, &#123;x, y&#125; + 2, 0, And], Catenate[Array[b, &#123;x, y&#125;]]][[1]], &#123;x, y&#125;]; 然后我们就可以用这个 SearchStillLife 函数来找静物。不过，它出奇地慢，找个16乘16大小的静物也要花上44秒： ArrayPlot[Boole@SearchStillLife[16, 16], Mesh -&gt; All] // AbsoluteTiming 能不能快一些？ 我不清楚这个 SatisfiabilityInstances 函数用的是什么算法。不过看了一下维基百科，SAT 问题最常用的好像是一种叫 DPLL 的算法。我完全不懂算法，就不管它的细节了。总之，它要求输入的是一个合取范式（CNF）。 于是，我们可以试试把条件转换成 CNF，也就是说，把前面的 StillLifeCondition 函数改写成： StillLifeCondition[i_, j_] := BooleanConvert[ (b[i, j] &amp;&amp; NeighborCount[&#123;2, 3&#125;, &#123;i, j&#125;]) || (! b[i, j] &amp;&amp; ! NeighborCount[&#123;3&#125;, &#123;i, j&#125;]), "CNF"]; 后面的 SearchStillLife 函数定义不变。现在再找一遍16乘16的静物，果然快了很多，只花了2.2秒。不过找出来的静物…… 看来 SatisfiabilityInstances 函数在处理 CNF 时用的是和别的形式不同的算法。满足条件的静物有很多，但 SatisfiabilityInstances 只会输出其中的第一个。而在输入 CNF 的时候，不巧空静物就是这“第一个”。 只能找到空静物的代码并没有什么用。我们可以试试给原来的代码引入一点随机的因素，让这个空静物不再是“第一个”。比如说，把原来数组异或上一个随机的数组，把前面的 SearchStillLife 函数改写成： SearchStillLife[x_, y_] := Block[&#123;r = RandomChoice[&#123;True, False&#125;, &#123;x, y&#125;]&#125;, MapThread[Xor, &#123;r, ArrayReshape[ SatisfiabilityInstances[ Array[StillLifeCondition[##] /. b[i_, j_] /; i &lt; 1 || i &gt; x || j &lt; 1 || j &gt; y :&gt; False /. b[i_, j_] :&gt; Xor[b[i, j], r[[i, j]]] &amp;, &#123;x, y&#125; + 2, 0, And], Catenate[Array[b, &#123;x, y&#125;]]][[1]], &#123;x, y&#125;]&#125;, 2]] 现在完整的代码变成了： NeighborCount[k_, &#123;i_, j_&#125;] := BooleanCountingFunction[&#123;k&#125;, Delete[Catenate[Array[b, &#123;3, 3&#125;, &#123;i, j&#125; - 1]], 5]];StillLifeCondition[i_, j_] := BooleanConvert[ (b[i, j] &amp;&amp; NeighborCount[&#123;2, 3&#125;, &#123;i, j&#125;]) || (! b[i, j] &amp;&amp; ! NeighborCount[&#123;3&#125;, &#123;i, j&#125;]), "CNF"];SearchStillLife[x_, y_] := Block[&#123;r = RandomChoice[&#123;True, False&#125;, &#123;x, y&#125;]&#125;, MapThread[Xor, &#123;r, ArrayReshape[ SatisfiabilityInstances[ Array[StillLifeCondition[##] /. b[i_, j_] /; i &lt; 1 || i &gt; x || j &lt; 1 || j &gt; y :&gt; False /. b[i_, j_] :&gt; Xor[b[i, j], r[[i, j]]] &amp;, &#123;w, h&#125; + 2, 0, And], Catenate[Array[b, &#123;w, y&#125;]]][[1]], &#123;x, y&#125;]&#125;, 2]] 这次能找到好看的静物了，花的时间时间在2.7秒左右： SeedRandom[233];ArrayPlot[Boole@SearchStillLife[16, 16], Mesh -&gt; All] // AbsoluteTiming 再试试大一点的静物，比如说64乘64的。花了大概46秒。 找完了静物，再来找振荡子（Oscillator）。振荡子是随时间周期变化的图样。于是，我们可以给那个布尔值的数组增加一个时间的维度，写成 Array[b, {p, w, h}]，这里 p 是它的周期。它们满足的条件也要作出相应的修改： NeighborCount[k_, &#123;t_, i_, j_&#125;] := BooleanCountingFunction[&#123;k&#125;, Delete[Flatten[Array[b, &#123;1, 3, 3&#125;, &#123;t, i - 1, j - 1&#125;]], 5]];OscillatorCondition[t_, i_, j_] := BooleanConvert[ (b[t, i, j] &amp;&amp; (b[t + 1, i, j] ⧦ NeighborCount[&#123;2, 3&#125;, &#123;t, i, j&#125;])) || (! b[t, i, j] &amp;&amp; (b[t + 1, i, j] ⧦ NeighborCount[&#123;3&#125;, &#123;t, i, j&#125;])), "CNF"];SearchOscillator[p_, w_, h_] := Block[&#123;r = RandomChoice[&#123;True, False&#125;, &#123;p, w, h&#125;]&#125;, MapThread[ Xor, &#123;r, ArrayReshape[ SatisfiabilityInstances[ Array[OscillatorCondition[##] /. &#123;b[t_, i_, j_] /; i &lt; 1 || i &gt; w || j &lt; 1 || j &gt; h :&gt; False, b[0, i_, j_] :&gt; b[p, i, j]&#125; /. b[t_, i_, j_] :&gt; Xor[b[t, i, j], r[[t, i, j]]] &amp;, &#123;p, w + 2, h + 2&#125;, 0, And], Flatten[Array[b, &#123;p, w, h&#125;]]][[1]], &#123;p, w, h&#125;]&#125;, 3]] （代码里的这个 ⧦ 符号表示的是等价，Mathematica 里显示为 ⇔。） 可能因为静物比较稀少，速度比找静物时慢了很多，找一个周期2的16乘16的静物花了11秒： SeedRandom[233];ArrayPlot[#, Mesh -&gt; All] &amp; /@ Boole@SearchOscillator[2, 16, 16] // AbsoluteTiming 周期3的就更慢了，找下面这个振荡子花了14分钟。 更高的周期我就不敢试了。 应该会有更快的办法。有好的建议欢迎评论。]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[π日，来吃个派]]></title>
    <url>%2F2018%2F03%2F14%2F%CF%80%E6%97%A5%EF%BC%8C%E6%9D%A5%E5%90%83%E4%B8%AA%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[原于2013年的π日发于果壳日志。这里转的是2016年的π日发在十五言的版本。转载到这个博客时把原来用 Mathematica 绘制的图片换成了 LifeViewer。 今天是π日，要吃派。 这是一个派： x = 3, y = 3, rule = B3/S23 3o$obo$obo! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 1 AUTOSTART ]] 嗯，其实是一个π……确切地说，是pi-heptomino，一个长成π的样子的七联骨牌。 不过，在生命游戏的世界里，这个π不听话，不好好地呆在那里，却要变成一堆奇怪的东西： x = 3, y = 3, rule = B3/S23 3o$obo$obo! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 240 GPS 30 Z 10 ]] #C [[ PAUSE 1 AUTOSTART ]] 不听话怎么办？把它吃掉！ 不过，这个π生活在生命游戏的世界里，不是我们人类的嘴巴能够吃掉的。 那叫谁去吃呢？ 生命游戏中有一类东西，英文名叫eater，有人把它翻译成“吞噬者”，不过我更喜欢把它翻译成“吃货”。它们能吞下玻璃而不伤身体……呃不，它们能把生命游戏中各种奇怪的东西吃掉，吃完之后自己会恢复原样。 让我们请出生命游戏中最出名的吃货：吃货一号（eater 1）： x = 4, y = 4, rule = B3/S23 2o$obo$2bo$2b2o! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 1 AUTOSTART ]] 长得像个鱼钩。其实，它的另一个名字就是鱼钩（fishhook）。它是生命游戏中第一个发现的吃货。 只需要四代时间，它就能吃掉一架滑翔机（glider）： x = 8, y = 7, rule = B3/S23 2bo$obo$b2o$4b2o$4bobo$6bo$6b2o! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 8 GPS 8 ]] #C [[ PAUSE 0.5 AUTOSTART ]] 也能轻松吞下轻型飞船（lightweight spaceship）和中型飞船（middleweight spaceship）： x = 24, y = 7, rule = B3/S23 b4o9b5o$o3bo8bo4bo$4bo13bo$o2bo2b2o5bo3bo2b2o$6bobo6bo4bobo$8bo13bo$8b 2o12b2o! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 11 GPS 8 ]] #C [[ PAUSE 0.5 AUTOSTART ]] 它还能吃掉很多别的东西，比如说面包（loaf）、小圆面包（bun）（大概给这些东西起名字的人也是个吃货）……这里就不再一一举例了。 那么，它能不能吃掉π呢？ 当然能。不过π太不听话了，一个吃货吃不掉，得两个。左边一个右边一个： x = 23, y = 4, rule = B3/S23 2o19b2o$bo8b3o8bo$bobo6bobo6bobo$2b2o6bobo6b2o! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 1 AUTOSTART ]] 嗯，吃得还挺快： x = 23, y = 4, rule = B3/S23 2o19b2o$bo8b3o8bo$bobo6bobo6bobo$2b2o6bobo6b2o! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 43 GPS 30 X 0 Y -3 ]] #C [[ PAUSE 0.5 AUTOSTART ]] 除了吃货一号，另一个吃货也能吃掉π： x = 2, y = 2, rule = B3/S23 2o$2o! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 1 AUTOSTART ]] 嗯，就是个方块（block）。它是生命游戏中最常见的一种静物（still life）。在平面上随机倒上一锅汤（soup，指随机的初始状态），然后开始生命游戏，等稳定下来之后基本上都能看到它。 它其实也是一个吃货，不过胃口没有吃货一号那么好。一些别的吃货，比如说吃货二号（eater 2），就是在它的基础上构造出来的。 和吃货一号一样，也是需要两个方块才能吃掉π： x = 9, y = 12, rule = B3/S23 2o5b2o$2o5b2o8$3b3o$3bobo$3bobo! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 1 AUTOSTART ]] （有点囧……） 这次就没有吃货一号吃得那么快了： x = 9, y = 12, rule = B3/S23 2o5b2o$2o5b2o8$3b3o$3bobo$3bobo! #C [[ GRID THEME Inverse AUTOHIDEGUI ]] #C [[ LOOP 80 GPS 30 Z 20 ]] #C [[ PAUSE 0.5 AUTOSTART ]] 不过总是把π吃掉了。 参考资料：LifeWiki 另外，卅猫说两个方块吃π的图片像苦力怕。 于是我试了一下。真正的苦力怕会变成两只蜂巢： x = 6, y = 6, rule = B3/S23 2o2b2o$2o2b2o$2b2o$b4o$b4o$bo2bo! #C [[ GRID AUTOHIDEGUI ]] #C [[ COLOR ALIVE 0 69 0 ]] #C [[ COLOR ALIVERAMP 0 69 0 ]] #C [[ COLOR DEAD 13 181 13 ]] #C [[ COLOR BACKGROUND 143 227 143 ]] #C [[ LOOP 8 GPS 8 ]] #C [[ PAUSE 0.5 AUTOSTART ]]]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行代码的分形]]></title>
    <url>%2F2017%2F12%2F20%2F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%88%86%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[继续搬运果壳网上的旧帖。部分代码有改动。 Wolfram 公司在 Twitter 上开了个帐号，叫 Tweet-a-Program (@wolframtap)。你只要发一段 Mathematica 代码并@它，它就会自动把运行结果回复给你。由于 Twitter 的字数限制，这段 Mathematica 代码不能超过128字（现在 Twitter 的字数限制涨了，但 Tweet-a-Program 的字数限制还是不变）。 我一般用它来画分形。 Multicolumn[Table[Image3D@Array[Boole@SubsetQ[s,Plus@@Abs[IntegerDigits[&#123;##&#125;,3,3]-1]]&amp;,&#123;3,3,3&#125;^3,0],&#123;s,Subsets@&#123;0,1,2,3&#125;&#125;],4] JuliaSetPlot[z-(z^9-1)/(9z^2),z,ColorFunction-&gt;"RustTones"] Image@Array[BitAnd,&#123;2,2&#125;^9,0] Image[1-Last@SubstitutionSystem[&#123;0-&gt;&#123;&#123;1,1,1&#125;,&#123;1,1,1&#125;,&#123;1,1,1&#125;&#125;,1-&gt;&#123;&#123;0,1,0&#125;,&#123;1,0,1&#125;,&#123;0,1,0&#125;&#125;&#125;,&#123;&#123;1&#125;&#125;,6]] Graphics[&#123;RGBColor@##3,Point@&#123;#,#2&#125;&#125;&amp;@@(2y^Range[7].#)&amp;/@Tuples[&#123;&#123;x=.886,y=.5,y,0,0&#125;,&#123;-x,y,0,y,0&#125;,&#123;0,-1,0,0,y&#125;&#125;,7]] Image[Table[If[ColorQ@#,#,Black]&amp;[Hue[(Arg@#+Pi)/(2Pi),1/Abs@#]&amp;[MandelbrotSetBoettcher[x+I y]]],&#123;y,-2,2,.01&#125;,&#123;x,-2,2,.01&#125;]] Graphics@Line[AnglePath@#,VertexColors-&gt;Hue/@Subdivide@Length@#]&amp;@MapIndexed[#(-1)^Tr@#2&amp;,Flatten@Nest[&#123;#,#[[1]]&#125;&amp;,&#123;Pi/2,0&#125;,17]] Multicolumn[Table[Image3D[Array[BitXor,&#123;2,2,2&#125;^5,0]/.&#123;i-&gt;1,_Integer-&gt;0&#125;],&#123;i,0,31&#125;],4] f=&#123;Tuples[Range[2^#]-1,#2],First@HilbertCurve@##&#125;&amp;;Grid@Table[Image@Partition[a[[Ordering@b]]/2^6,2^9],&#123;a,f[6,3]&#125;,&#123;b,f[9,2]&#125;]]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mathematica 二三事]]></title>
    <url>%2F2017%2F11%2F28%2FMathematica%E4%BA%8C%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[原发于果壳网Matlab小组。没错，是Matlab小组。 这样一个标题出现在Matlab小组里是不是有点奇怪？1 第一件事，还是在2011年，当时果壳网的小组还不多，死理性派小组的风气也还好。当时@dwt 发了个“表白函数”的帖子，引来大家的膜拜： 于是我把这帖子转到了百度贴吧，并照着图片把这段代码打了出来，不过没说明用的是什么软件。 帖子不久就沉了。然后过了几个月，迎来这么一个回帖： 第二件事还是与果壳网有关。当时是2012年，知性社区2还是果壳网的一个小组，叫做性情。当时有人发了一个帖子，帖子里用一个函数（数学上的函数，不是编程语言的函数）画了一个胸部的曲线。 我在回帖中将函数公式修改了一下，把曲线变成曲面，并贴出了Mathematica代码。当然，也没有说明用的是Mathematica，不过我当时用的号在果壳认证的头衔就是“Mathematica玩家”，于是在果壳里也没有引起误会。 然后果壳网将这个帖子的内容连着我的回复推到了微博上面： 我很高兴，然后在这条微博的评论和转发里看到了这样的内容： 我去装Matlab了 回去到matlab里试试。。。 这个是用matlab画的。。。原来数学之美是介个意思。。 当初学matlab的时候，如果你拿这个作示范，我相信我会学得更认真点的 神马都敌不过数学之美！！！伟大的MATLAB！！！ ………… 第三件事是在最近3。在知乎，有人问了一个问题：如何用数学软件画一个“圣诞树”? 我刚好在codegolf.stackexchange.com上见过一个类似的问题，那里有个网友用Mathematica给了一个很漂亮的回答，于是把那个答案搬运了过来。总之画出来是这样的： 这个答案在知乎里获得了50多个赞，还有20个收藏。其中有个收藏夹名字叫matlab。我想，大概他是懒得开一个Mathematica的收藏夹，就把这个答案跟一些与Matlab有关的答案放在一起吧。这样想着，我点开了那个收藏夹。 收藏夹里只有一个答案。 我发誓这次我是清清楚楚地写了“用的是Mathematica”的。 1. 不，我没有要黑Matlab及其用户的意思。 &#8617; 2. 现在知性社区也没了。果壳网也差不多没了。 &#8617; 3. 2014年12月16日。 &#8617;]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维基词典的图标]]></title>
    <url>%2F2017%2F11%2F28%2F%E7%BB%B4%E5%9F%BA%E8%AF%8D%E5%85%B8%E7%9A%84%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[果壳网已完。也许第二天我的帖子就会消失。以防万一，我决定把我发过的一些帖子搬运到简书。也包括这么无聊的帖子。 这个帖子原发于果壳网维基百科小组。 除了中文、英文的维基百科，我用的最多的一个维基旗下网站就英文维基词典。用得虽然多，平时并没有盯着图标看，因此并不知道图标是什么时候换的。 我刚接触维基词典的时候，英文维基词典的图标是这样的： 不过我觉得，在基本只有黑白两色的网页上配上一个彩色的图标，挺丑的。 很多别的语言的维基词典借用了这个图标。中文维基词典至今还在用一个与其类似的图标，不过把W字和维字换了一下位置： 顺便吐槽一下乌克兰文的维基词典，这崩坏的“漢”字： 说回英文维基词典。后来，它换成了这么一个图标： 这是我最喜欢的一个图标。不过我看了一下文件历史，它的上传时间比上一个图标还要早。可能是这两个图标轮换使用吧。 也有不少语言的维基词典参考了这一图标。由于语言不同，只能参考，不能照搬，于是做得各有特色。比如说这是俄语维基词典使用至今的图标： 不过，图标里的注音也会引发一点争议，比如说wiktionary里的a该不该发音。英文维基词典的图标就有过这么一个提议，注意这里的国际音标中a的发音： 俄语维基词典甚至为了修正国际音标而换过一次图标。 然后，不知什么时候，英文维基换成了现在的图标。它应该是基于第一个图标，但简洁了许多： 我暂时还没有发现别的语言的维基百科采用这一图标。有趣的是，在维基共享资源的Wiktionary logos分类里也找不到这一图标。我暂时还没有发现别的语言的维基百科采用这一图标。有趣的是，在维基共享资源的Wiktionary logos分类里也找不到这一图标。 更新于 2019-03-17：发现了这么一个页面，列出了所有语言的维基词典的图标。英文维基词典的图标在维基共享资源的SVG Wiktionary logos分类里。土耳其语的维基词典也使用了和英文类似的图标。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
        <tag>维基百科</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Mathematica 搜索生命游戏中的静物]]></title>
    <url>%2F2017%2F11%2F06%2F%E7%94%A8-Mathematica-%E6%90%9C%E7%B4%A2%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E9%9D%99%E7%89%A9%2F</url>
    <content type="text"><![CDATA[用 Mathematica 搜索生命游戏中的静物（二） 用 Mathematica 搜索生命游戏中的静物（三） 果壳网已死。临死前元胞自动机小组还回光返照了一段时间——虽然真正活跃的人大概不超过五个。 以下的代码就算是我给果壳网以及元胞自动机小组烧的一点纸钱吧。 a = Merge[ k[#[[;; 2]], CellularAutomaton["GameOfLife", #][[2, 2]]] -&gt; #[[3]] &amp; /@ Tuples[Tuples[&#123;0, 1&#125;, 3], 3], Identity];g[x_, y_, z_] := FindPath[Flatten@ MapIndexed[ Outer[v[#2 - 1, Most[#1]] -&gt; v[#2, Rest[#1]] &amp;, ##, 1] &amp;, Lookup[a, MapThread[ k, &#123;First[ Partition[&#123;x, y&#125;, &#123;2, 3&#125;, &#123;2, 1&#125;, &#123;&#123;1, -2&#125;, &#123;-1, 2&#125;&#125;, 0]], z&#125;], &#123;&#125;]], v[0, &#123;0, 0&#125;], v[Length[z], &#123;0, 0&#125;], Length[z] + 2, All][[;; , 2 ;;, 2, 1]];With[&#123;w = 16, h = 16&#125;, o = Table[0, w + 2]; i = g[o, o, o]; f[l : &#123;___, x_, y_&#125;] := If[Length@l == h + 2, If[y == o &amp;&amp; MemberQ[i, x], l, Missing["NotFound"]], Catch[Do[ If[MissingQ[#], , Throw[#]] &amp;[f[Append[l, z]]], &#123;z, RandomSample[g[x, y, y]]&#125;]; Missing["NotFound"]]]; SparseArray[f[&#123;o, RandomChoice[i]&#125;]]] 返回的结果是一个SparseArray，可以用ArrayPlot来转换成图片。这是搜索16*16的静物。把With[{w = 16, h = 16},里的16换成别的数字可以搜索别的大小的静物，但不要把w改得太大。如果一次搜索的时间太久，可能是运气不好，可以用Alt+.来中断计算。 下面是5次搜索的结果： x = 16, y = 16, rule = B3/S23 ob2o2bob2o5bo$2ob4obobo2b3o$9bo2bo$5o5b2ob3o$o2bobob3o2bo2bo$5bobo3bo2bo$4bo3b2ob3o$o2bob3o2bo$4obo2bo2bob3o$5bo2b2ob2o2bo$3obo4bo4bo$o2b2obo2bob2ob2o$bo3b2o3bobo2bo$2b2o10bo$obob3o4b3o$2o4bo4bo! x = 16, y = 16, rule = B3/S23 bo11bobo$b3o6bobob2o$4bobob3obo$b2obob2o4bo$o2bo5b2obobo$2o8bo2bobo$6bobo2bobobo$3bobob5ob2o$b3obo$o4b3obob4o$b4o3b3o4bo$3bo2bo5bo2bo$5b2ob7o$b4o3bo$bo3bobo3bob2o$4b2ob2o2b2obo! x = 16, y = 16, rule = B3/S23 2bobob2obobobo$bob2obob2ob2obo$bo4bo3bo3bo$2bob3o3bo3b2o$ob2o5b2obobo$2o3b2o4b2obo$3b2ob4o3bo$2obo5bob2o$2o3b2o2bobo$3bobobobobo$3obo2b2obob2o$o3bobo3bo3bo$4b2obobob2obo$2b2o3bobo3bo$bo2bob2o2bobo$2b2o5b2ob2o! x = 16, y = 16, rule = B3/S23 2b2obo4bo3b2o$bob2obob3o2bobo$o5b2o3b3o$b5o3b2o4bo$2bo2bob3o2b4o$o5bo4b2o$2o6b3o3b2o$bo4bobo2b2obo$bobo2b2o3bo2bo$2ob3o6bob2o$bo4b2o3b2o2bo$bob2obo5bobo$2o2bo3bobo3b2o$2bobo2b2ob2o2bo$2bobobo2bo2bobo$3b2ob2o3b2ob2o! x = 16, y = 16, rule = B3/S23 bobo2bob2o2bobo$ob6ob5obo$o14bo$b4ob5ob3o$4b2o4bobo$obo4bo2bo2bobo$2ob8o3b2o$3bo$2obo2bo2b2o$bob4o3bo2bobo$o9bobob2o$3obo4b2obo$3b2o3bo4b3o$2o5bobob2o2bo$ob3o3b2obo2bo$4bo7b2o!]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Catagolue 上的生命游戏搜索程序]]></title>
    <url>%2F2017%2F10%2F01%2FCatagolue-%E4%B8%8A%E7%9A%84%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%90%9C%E7%B4%A2%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[注意：apgluxe 的原作者为 Catagolue 提供了另一个域名：gol.hatsya.co.uk。这个没有被墙。只需把原版的 apgluxe 中的 catagolue.appspot.com 换成 gol.hatsya.co.uk 就能正常工作了。原版的最新版也已经添加这个地址（如果访问不稳定，可以尝试在 ping 得通的时候记下 ip 地址，然后改 Host）。因此这里说离线版已经没有意义了。 不久前，我发现了这个叫 Catagolue 的神奇的网站，收录的规则和图样比 LifeWiki 要全得多。 这里收录的图样都是用一个叫 apgsearch 的程序找出来的。apgsearch 的不同版本有不同的名字，最新的第4版叫 apgluxe。它的功能就是自己倒汤，煮汤，然后在汤的残骸中自动搜索有意义的图样，然后自动上传到 Catagolue 上。 不过，正是因为这最后一步，这个程序无法在中国大陆正常运行：Catagolue 用的是谷歌旗下某网站的域名，于是被墙了。而且有翻墙工具也没用，因为它用了个叫 HappyHTML 的东西，不支持代理！ 无奈之下，我把它改了一下，去掉与上传有关的部分。我完全不懂 C++，只能胡乱修改，把看起来像是和联网有关的内容都删掉，好像能够正常编译，不能保证不会有错。 这是我修改后的离线版：https://github.com/AlephAlpha/apgluxe_offline 这个程序（无论是原版还是我修改后的离线版）是写给64位的 Unix 系统的，32位的操作系统没法使用。在64位的 Windows 上要用的话好像要先装个 Cygwin。反正我不用 Windows。 下载这个程序时可以用git clone，也可以直接下载 ZIP 压缩包。在下载好之后，要编译程序，在终端里 cd 到这个目录里，然后运行： ./recompile.sh 即可。 要运行程序的话，在同一个目录里，运行： ./apgluxe -n 1000000 这里的1000000是每一轮倒的汤的数量，可以换成你喜欢的任何数字。每倒完一轮，会生成一个统计结果，保存在一个类似于 log.一串类似于乱码的东西.txt 的文件当中（图样用的是 apgcode 格式，我不知道怎样转成 rle 或者别的 Golly 能读的格式），然后自动开始下一轮。什么时候不想玩了，按 Ctrl+C 可以退出。也可以不加 -n 1000000 这个参数，这样默认每轮会煮20000000锅汤（我觉得这个数字有点太大了）。如果 CPU 是多核的，还可以加 -p 4 这样的参数来并行运算，这个4表示4个线程。 运行时如果找到线性增长的图样（一般是 Block-laying switch engine 或者 Glider-producing switch engine），或者罕见的周期大于2的振荡子，它会直接告诉你。刚才试了一轮，煮到将近第九十万锅汤的时候找到一个 xp30_w33z8kqrqk8zzzw33，在 Catagolue 上查了一下是个蜂王梭，运气不错。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汤，以及生命游戏里的稀有掉落]]></title>
    <url>%2F2017%2F10%2F01%2F%E6%B1%A4%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E9%87%8C%E7%9A%84%E7%A8%80%E6%9C%89%E6%8E%89%E8%90%BD%2F</url>
    <content type="text"><![CDATA[原发表在十五言 汤，英文叫 soup，或者 broth，在生命游戏里指的是随机的初始状态。 很多人刚接触生命游戏的时候，第一种玩法就是倒上一锅汤，然后开始游戏，看着这些方块变来变去，直到整个局面稳定下来为止。 稳定下来之后，游戏的画面一般不再有大的变化，只散落着一些静止不动的小部件，叫做静物（still life）；以及一些周期性地动来动去的小东西，叫做振荡子（oscillator）。就像这样： 对很多人来说，游戏到了这里就结束了，然后就是关掉游戏或者再来一局。 不过，既然是游戏，为什么不观察一下，看看自己刷出了什么稀有掉落呢？ 怎样才算稀有掉落？ Achim Flammenkamp 在2048*2048的环面上，以密度为0.375的汤为初始条件，进行了1829196场游戏，统计出了稳定下来之后最常见的100种物体。 常见的物体还有自己的名字，比如说，排名前十的如下（没有统一的中文翻译，这里给的只是我个人的翻译；图片均来自 LifeWiki）： 一、闪闪 Blinker 二、方块 Block 三、蜂巢 Beehive 四、面包 Loaf 五、小船 Boat 六、澡盆 Tub 七、池塘 Pond 八、大船 Ship 九、长船 Long boat 十、蛤 Toad 完整排名见这里。表中排名靠后的，或者表上没有的，绝对算是稀有掉落了。 在上面那幅图中，我刷出来的最罕见的物品，大概是左上角的一个脉冲星（CP pulsar）。它是一个周期为3的振荡子，个头很大，特别醒目。在表上排行19，算不上太稀有，不过是前100个物体中个头最大的，也是最常见的周期大于2的振荡子： 表中的100种物体绝大多数都是静物，振荡子只占了8个。脉冲星在振荡子中排第四，仅次于闪闪、蛤和信标（Beacon）。 同一个网页中的另一个表格则列出了最常见的——确切地说，在整个实验中出现了两次或以上的——振荡子。除了排名靠前的几种之外，其余的都特别少见。 能出现在表格中的振荡子大部分周期都比较短，只有2或者3。但也有个别周期比较长的。其中周期最长的是下图中的蜂王梭（Queen bee shuttle）： 蜂王梭在生命游戏中是一个非常重要的物体，很多有意思的物体都是以它为基础造出来的，比如说下图中的 Gosper 滑翔机枪（Gosper glider gun）。不过根据 Achim Flammenkamp 的统计，蜂王梭的出现率低于一亿分之一，除非是用专门的搜索程序，不然是不太可能看到了。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>生命游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毛利语中化学元素的名称]]></title>
    <url>%2F2017%2F04%2F23%2F%E6%AF%9B%E5%88%A9%E8%AF%AD%E4%B8%AD%E5%8C%96%E5%AD%A6%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[原发于果壳 Today I Learned 小组。 毛利语是新西兰原住民毛利人的语言，属于南岛语系马来-波利尼西亚语族。 大部分语言里化学元素的名称，除了金银铜铁等少数几个元素，都是借自拉丁语或者英语。毛利语是个例外，他们用的是自己造的新词。 这些新词大多是由现有的词拼成的复合词，而且造词的办法有点像中国化学家造的那批汉字：气体元素都有hau（气体）这个前缀，而金属元素用的是konu（金属）这个前缀。 不过非气体的非金属元素没有统一的前缀。其中一些用的是pū——毛利语中“元素”一词（pūmotu）的第一个音节。比较特别的是碘：hautawa，直译为“紫气”。碘在常温下是固体，但容易升华成紫色气体。 下面是毛利语中前面二十个元素的名称及其含义： 汉语 元素符号 毛利语 含义 氢 H hauwai hau 气 + wai 水 氦 He haumāmā hau 气 + māmā 轻 锂 Li konukōhatu konu 金属 + kōhatu 石 铍 Be konuuku konu 金属 + uku 黏土 硼 B pūtiwha pū[pūmotu] 元素 + tiwha 闪光 碳 C waro 煤；炭 氮 N hauota hau 气 + ota 植物 氧 O hāora hā 呼吸 + ora 活着 氟 F haukōwhai hau 气 + kōwhai 黄 氖 Ne haukura hau 气 + kura 红 钠 Na konutai konu 金属 + tai 海 镁 Mg konupora konu 金属 + pora 一种白色石头 铝 Al konumohe konu 金属 + mohe 软 硅 Si takawai 石英 磷 P pūtūtaewhetū 磷光物质（？） 硫 S pungatara 自然硫 氯 Cl haumāota hau 气 + māota 绿 氩 Ar hauhauhā hau 气 + hauhā 二氧化碳 钾 K konurehu konu 金属 + rehu 尘；雾 钙 Ca konupūmā konu 金属 + pūmā 灰白色 参考资料： https://mi.wikipedia.org/wiki/Ripanga_p%C5%ABmotu http://putaiao.tki.org.nz/Papakupu-Putaiao/Nga-Kupu-Maori]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>果壳搬运</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DipDup]]></title>
    <url>%2F2017%2F01%2F20%2FDipDup%2F</url>
    <content type="text"><![CDATA[在之前的《那些奇奇怪怪的编程语言》一文里，我介绍了 Esolang 的概念，以及几种 Esolang 的例子。当然，这种事情自己动手更有意思。于是我也设计了一种编程语言，叫做 DipDup。 DipDup 是一种基于堆栈的编程语言。它的设计参考了另外两种基于堆栈的编程语言：Underload 和 Joy。 Underload 是一种极简主义的编程语言，由 Ais523 设计于2006年。它只有七条指令（或者是八条，如果把列表也算作一种指令的话）。除了表示输出的S之外，都是一些简单的堆栈操作。Underload 是图灵完备的。如果你设计了一种基于堆栈的编程语言，想要证明它是图灵完备的，只需要用它实现一下 Underload 里的这些指令就行了。 Joy) 由 Manfred von Thun 设计于2001年。它不是 Esolang。除了基于堆栈（确切地说，是 Concatenative，这个词不知道怎么翻译）以外，它没有太多奇怪的地方，一门普通的编程语言该实现的功能它都有实现。不过 Manfred von Thun 设计这门语言主要是出于学术用途，实际使用的人不多。 DipDup 可以看作是 Joy 的一个子集。我从 Joy 的两百多条指令当中选取了四条：dip，dup，pop 和 cons，分别把它们记作 ^，_，! 和 :。DipDup 这个名字就是从这里来的。 DipDup 是一种基于堆栈的语言，它的每一条指令都可以看作是一个把堆栈映成堆栈的函数。把几条指令写成一串，相当于是函数的复合，得到的依然是一个把堆栈映成堆栈的函数。 四条指令的介绍如下： dupdup 指的是 duplicate，复制。如果原先的堆栈是 ...ba（堆栈的顶端写在右边），执行操作后堆栈变成 ...baa。在 DipDup 当中，dup 写成 _。 pop不同于别的编程语言里的 pop，它把堆栈顶上的东西弹出之后就扔掉了，不会返回也不会输出。如果原先的堆栈是 ...ba，执行操作后堆栈变成 ...b。在 DipDup 当中，pop 写成 !。 cons类似于 Lisp 里的 cons 和 Haskell 里的 :。如果原先的堆栈是 ...b[a]，执行操作后堆栈变成 ...[ba]。在 DipDup 当中，cons 写成 :。 dip这个有点复杂，不过它是 DipDup 里最关键的一条指令。如果原先的堆栈是 ...cb[a]，它会先弹出 [a] 和 b，然后把 [a] 当成一个程序作用在堆栈 ...c 上，最后把 b 压回堆栈。在 DipDup 当中，dip 写成 ^。 除了四条指令之外，还有列表。一个列表就是把若干个指令和列表写成一串，中间不加任何分隔符，然后用方括号 [ 和 ] 括起来。比如说，[] 就是一个列表，[[_:]_:] 也是一个列表。在程序中，列表可以看作是一个指令，其作用是把这个列表本身压入堆栈。一个列表也可以看作是一段程序（是的，代码即数据），或者一个函数，可以作用在堆栈上（比如说，借助 dip 指令）。 初始的堆栈由无穷多个空列表组成——采用无穷堆栈是因为我懒得处理堆栈为空的情况。在程序运行完了之后，输出的是堆栈最顶上的东西。 举个最简单的例子，这是一个 Quine)，它输出的结果和程序本身一模一样： [_:]_: 然后问题来了：DipDup 是图灵完备的吗？ 前面说过，要证明一个基于堆栈的编程语言是图灵完备的，只需要用它实现一下 Underload 里的全部指令就行了。 除了列表之外， Underload 只有7种指令。其中 S表示输出，对图灵完备与否没有影响；: 就相当于 DipDup 里的 _（dup）；! 就相当于 DipDup 里的 !（pop）；a 表示用括号把堆栈最顶上的东西括起来，这个在 DipDup 里用 []: 就能实现；~ 表示交换堆栈最顶上的两个东西，相当于 Joy 里的 swap，这个在 DipDup 里可以用 []:^ 实现；^ 表示弹出堆栈最顶上的东西（必须是个列表），并把它作为一个程序作用在剩下的堆栈上，相当于 Joy 里的 i，这个在 DipDup 里可以用 []^! 或者 _^! 实现。 于是，我们只剩下一条指令没有实现：*。它表示的是弹出堆栈最顶上的两个东西（两个都是列表；事实上，无论是 Underload 还是 DipDup，堆栈里的东西都只有列表），把它们串接成一个列表，再压回堆栈。如果原先的堆栈是 ...[b][a]，执行操作后堆栈变成 ...[ba]。看起来与 DipDup 里的 cons 很像。但遗憾的是，这个用 DipDup 是实现不了的。 不过，我们可以换一条思路，先来看看 Underload 的图灵完备性是怎样证明的。Esolang Wiki 里给出的办法是证明所有的 Unlambda 代码都可以直接翻译成 Underload。Unlambda 是一种基于组合子逻辑的 Esolang，它是图灵完备的，因此 Underload 也是图灵完备的。 因此，我们也可以试着把 Unlambda 翻译成 DipDup。事实上，不需要翻译整个 Unlambda，只需要实现 S 和 K 这两个组合子就够了（当然，还需要用上 Underload 里的 ^，也就是 DipDup 里的 _^!）。它们的实现不算复杂： K 组合子 [[[!]^]:] S 组合子 [[[[[_]^^]^_^!_^!]::]:] 具体的推导我就不写了。 最后附上用 Haskell 写的解释器： import System.Console.Haskelineimport Text.ParserCombinators.ReadPdata Term = C Char | E Exprtype Expr = [Term]instance Show Term where show (C c) = [c] show (E e) = "[" ++ show e ++ "]" showList = (++) . concatMap showinstance Read Term where readsPrec = const $ readP_to_S readTerm readList = readP_to_S readExprreadTerm :: ReadP TermreadTerm = (C &lt;$&gt; satisfy (`notElem` "[]")) +++ (E &lt;$&gt; between (char '[') (char ']') readExpr)readExpr :: ReadP ExprreadExpr = many readTermdata Stack = Expr :-: Stackinfixr 5 :-:initStack :: StackinitStack = [] :-: initStacktop :: Stack -&gt; Exprtop (x :-: _) = xtype Func = Stack -&gt; StackevalTerm :: Term -&gt; FuncevalTerm (E e) = (e :-:)evalTerm (C '^') = dipevalTerm (C '_') = dupevalTerm (C '!') = popevalTerm (C ':') = consevalTerm _ = idevalExpr :: Expr -&gt; FuncevalExpr = flip . foldl $ flip evalTermeval :: Expr -&gt; Expreval = top . flip evalExpr initStackdip :: Funcdip (x :-: y :-: s) = y :-: evalExpr x sdup :: Funcdup (x :-: s) = x :-: x :-: spop :: Funcpop (_ :-: s) = scons :: Funccons (x :-: y :-: s) = (E y : x) :-: srep :: String -&gt; Stringrep input = case [x | (x, "") &lt;- reads input] of [x] -&gt; show $ eval x _ -&gt; error "parse error"repl :: InputT IO ()repl = do minput &lt;- getInputLine "&gt; " case minput of Nothing -&gt; return () Just input -&gt; do catch (outputStrLn $ rep input) $ \e -&gt; outputStrLn $ show (e :: SomeException) replmain :: IO ()main = runInputT defaultSettings repl]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>Esolang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触手]]></title>
    <url>%2F2017%2F01%2F01%2F%E8%A7%A6%E6%89%8B%2F</url>
    <content type="text"><![CDATA[注：当年想在卅猫传说的框架下写一点克苏鲁神话风格的东西，但只写了个开头…… 乌图人信仰的一神教，崇拜一位独一的真神——赫屠鲁（Xtulu）。 随着乌图帝国的扩张，对赫屠鲁的信仰也被带到北土西方的每一个角落。使用各种不同语言的民族，用各种奇怪的发音来念诵赫屠鲁的名字。不同地区的艺术家也把赫屠鲁的形象描绘得千奇百怪。但有一点是不变的——触手。 赫屠鲁的下巴上有触手，这是经书上写明了的。经书上还写了，它用泥土捏出最早的人类的时候，用的不是锋利的双爪，而是触手；它掀起飓风与洪水的时候，用的不是背上的双翼，而是触手；甚至在操纵天上的星辰的时候，用的也是触手。民间流传着这样一种说法：它的每一根触手，对应着天上的一个星座；当群星处在正确的位置之时，赫屠鲁便会重返人间。 经书上也没有说清楚触手的数量，于是这成了教派纷争焦点：古老的三十六触手宗，新兴的七十二触手宗，帝国钦定的八十八触手宗，民间流传的一百触手宗，东方的一百零八触手宗，南土的八十一触手宗，被视为异端中的异端的一百三十七触手宗…… 触手是从哪里来的？ 北土出现过的其它神灵都没有触手。于是，神学家们宣称：这就是赫屠鲁是唯一的真神的证据，没有触手的都是伪神。 不信神的萨满们当然不会接受这种解释。乌图人来自北土的最南方，于是他们很自然地把目光落到比北土的最南方更南的地方——南土。 他们沿着乌图人扩张的历史，不难就追溯到了赫屠鲁信仰的源头——它来自于南土的一支渔民所信仰的海神。乌图人在与这些渔民的接触中接受了这个神灵，并把它与乌图人信仰的其它神灵的形象融合起来——它已变得面目全非，但经书上的一些故事还能在南土渔民的传说中找到原型；而且，它还保留着触手。 但是，这位个南土的海神的触手又是从哪里来的呢？这些渔民没有自己的文字，对自己民族的历史也语焉不详。萨满们只能猜测，海神的触手是来自于某种海洋生物——也许是章鱼，也许是水母，也有可能是龙——如果对龙须进行某种夸张，看起来确实很像触手。 但这一猜测很快就被推翻——随着北土人接触到南土更多的民族，他们发现了更多长着触手的神灵。这些民族的语言、文化和生活的环境各不相同，相互之间也没有什么接触，有些民族生活的环境里根本没有肉眼可见的任何长着触手的生物。这些神灵没有任何触手之外的共同点，甚至触手长的部位也各不相同。有的民族还同时信仰多位长有触手的神灵，并且相信，触手越多的神灵越强大。 北土的萨满和人类学家组成了一支探险队，决定深入南土深处，一探究竟。越是往南，他们发现了越多的触手神灵，神灵身上的触手也越来越多。崇拜的仪式变得越发诡异，神灵的形象也越发离奇，已经没有了任何人类和人们所熟悉的动物的特征。谁能想到，在南土的丛林里的一些与世隔绝的部落，在木头上雕刻出的粗糙的神像，却能远远超出北土最疯狂的艺术家的想象？ 但探险队的成员一直没有把这些触手怪当成真实的存在。直到他们继续往南，在接近了南土的中心的地方发现了一种新的信仰形式——这里的人信仰的不是别的神灵，而是触手本身。而且，在当地人的宗教仪式上，探险队员们看到了活生生的触手。 （未完）]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rime 西里尔拼音输入方案]]></title>
    <url>%2F2016%2F10%2F06%2FRime-%E8%A5%BF%E9%87%8C%E5%B0%94%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[这是我给 RIME 输入法弄的一个输入方案，通过西里尔字母来输入中文。采用的是俄罗斯汉学家 Пётр Иванович Кафаров （教名Palladius）设计的转写方案。使用前请背熟俄文键盘，但使用时不要将自己的键盘布局切换成俄文。 截图： # Rime schema# vim: set sw=2 sts=2 et:# encoding: utf-8schema: schema_id: palladius name: "西里尔拼音" version: "0.0" author: - AlephAlpha &lt;alephalpha911@gmail.com&gt; description: | 通过西里尔转写（Систима Палладия）输入中文switches: - name: ascii_mode reset: 0 states: [ 中文, 西文 ] - name: full_shape states: [ 半角, 全角 ] - name: simplification reset: 1 states: [ 漢字, 汉字 ]engine: processors: - ascii_composer - key_binder - speller - punctuator - selector - navigator - express_editor segmentors: - ascii_segmentor - abc_segmentor - punct_segmentor - fallback_segmentor translators: - punct_translator - r10n_translator filters: - simplifier - uniquifierspeller: alphabet: '`qwertyuiop[]asdfghjkl;''zxcvbnm,.' delimiter: " " algebra: - erase/^xx$/ - xform/^([zcs])i/$1I/ - xform/^([jqxy])u/$1v/ - xform/^j/cz/ - xform/^q/c/ - xform/^x/s/ - xform/^zh/CZ/ - xform/^ch/C/ - xform/^sh/S/ - xform/^r/Z/ - xform/^z/cz/ - xform/^you$/iu/ - xform/^yv/v/ - xform/^yi?/i/ - xform/^wu$/u/ - xform/ong$/ung/ - xform/uo$/o/ - xform/v$/iui/ - xform/v/iu/ - xform/([aeou])i$/$1y/ - xform/n$/nY/ - xform/ng$/n/ - xform/ia/A/ - xform/ie/E/ - xform/io/O/ - xform/iu/U/ - derive/uy$/uey/ - derive/huy/hoy/ - derive/([bpmf])en/$1In/ - derive/^e$/I/ - derive/([CSZ])i/$1I/ - abbrev/^([A-Za-z]).+$/$1/ - abbrev/^(cz|CZ).+$/$1/ - abbrev/^(.+)Y$/$1/ - 'xlit|abwgdEOZziyklmnoprstufhcCSXHIYeUA|f,dult`;pbqrkvyjghcnea[wxio]sm''.z|'translator: dictionary: luna_pinyin prism: palladius preedit_format: - 'xlit|`qwertyuiop[]asdfghjkl;''zxcvbnm,.|ёйцукенгшщзхъфывапролджэячсмитьбю|' - xform/хуй/хуэй/punctuator: full_shape: ' ' : &#123; commit: ' ' &#125; '/' : &#123; commit: 。 &#125; '?' : &#123; commit: ， &#125; '\' : [ 、, ＼, ｀ ] '|' : [ ／, ÷, ｜, '§', '¦' ] '!' : &#123; commit: ！ &#125; '@' : &#123; pair: [ '“', '”' ] &#125; '#' : [ ＃, ⌘ ] '$' : &#123; commit: ； &#125; '%' : [ ％, '°', '℃', ＆ ] '^' : &#123; commit: ： &#125; '&amp;' : &#123; commit: ？ &#125; '*' : [ ＊, ·, ・, ×, ※, ❂, ＠, ☯, ￥, '$', '€', '£', '¥', '¢', '¤' ] '(' : [ （, 「, 【, 〔, ［, 『, 〖, ｛, 《, 〈, «, ‹, ‘ ] ')' : [ ）, 」, 】, 〕, ］, 』, 〗, ｝, 》, 〉, », ›, ’ ] '-' : [ －, ～ ] '_' : [ ——, …… ] '+' : ＋ '=' : ＝ half_shape: '/' : &#123; commit: 。 &#125; '?' : &#123; commit: ， &#125; '\' : [ 、, '\', '`' ] '|' : [ 、, '/', ÷, '|', '§', '¦' ] '!' : &#123; commit: ！ &#125; '@' : &#123; pair: [ '“', '”' ] &#125; '#' : [ '#', №, ⌘ ] '$' : &#123; commit: ； &#125; '%' : [ '%', '°', '℃', '&amp;' ] '^' : &#123; commit: ： &#125; '&amp;' : &#123; commit: ？ &#125; '*' : [ '*', ·, ・, ×, ※, ❂, '@', ☯, ￥, '$', '€', '£', '¥', '¢', '¤' ] '(' : [ （, 「, 【, 〔, ［, 『, 〖, ｛, 《, 〈, «, ‹, ‘ ] ')' : [ ）, 」, 】, 〕, ］, 』, 〗, ｝, 》, 〉, », ›, ’ ] '-' : [ '-', '~' ] '_' : [ ——, …… ] '+' : '+' '=' : '='key_binder: import_preset: default bindings: - &#123; when: has_menu, accept: comma, send: comma &#125; - &#123; when: has_menu, accept: period, send: period &#125;]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>文字游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粤语西里尔字母转写方案]]></title>
    <url>%2F2016%2F10%2F06%2F%E7%B2%A4%E8%AF%AD%E8%A5%BF%E9%87%8C%E5%B0%94%E5%AD%97%E6%AF%8D%E8%BD%AC%E5%86%99%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[这肯定不是世界上第一套粤语西里尔字母转写方案。俄文维基百科里就有一套现成的。虽然我不太喜欢那套方案，尤其不喜欢那个莫名其妙的冒号（:），但我自己设计的方案也未必比它更好。 转写的是香港语言学学会粤语拼音方案反映的这套粤语音系，即所谓“标准粤语”。和我为普通话设计的那套拼音方案一样，一个音位尽量只用一个字母来表示，避免用几个字母的组合来表示一个发音——这也是使用西里尔字母的语言的惯例。 同样，这也只是图个好玩，完全不考虑实用性。 以下的国际音标和例字均取自维基词条“香港语言学学会粤语拼音方案”，仅供参考。 声母 粤拼 西里尔 国际音标 例字 b б /p/ 巴 ба p п /pʰ/ 怕 па m м /m/ 妈 ма f ф /f/ 花 фа d д /t/ 打 да t т /tʰ/ 他 та n н /n/ 那 на l л /l/ 啦 ла g г /k/ 家 га k к /kʰ/ 卡 ка ng ң /ŋ/ 牙 ңа h х /h/ 哈 ха gw гу /kʷ/ 瓜 гуа kw ку /kʰʷ/ 夸 куа w в /w/ 蛙 ва z џ /ts/ 渣 џа c ч /tsʰ/ 叉 ча s с /s/ 沙 са j й /j/ 也 йа 韵母韵腹 粤拼 西里尔 国际音标 例字 aa а /aː/ 沙 са a ә /ɐ/ 新 сән e е /ɛː/ &lt;/br&gt; /e/ 些 се &lt;/br&gt; 四 сей i и /iː/ &lt;/br&gt; /ɪ/ 诗 си &lt;/br&gt; 识 сик &lt;/br&gt; 星 сиң o о /ɔː/ &lt;/br&gt; /o/ 疏 со &lt;/br&gt; 苏 соу oe &lt;/br&gt; eo ө /œː/ &lt;/br&gt; /ɵ/ 靴 хө &lt;/br&gt; 询 сөн u у /uː/ &lt;/br&gt; /ʊ/ 夫 фу &lt;/br&gt; 风 фуң &lt;/br&gt; 福 фук yu ү /yː/ 书 сү 韵尾 粤拼 西里尔 国际音标 例字 p п /p̚/ 湿 сәп t т /t̚/ 失 сәт k к /k̚/ 塞 сәк m м /m/ 心 сәм n н /n/ 新 сән ng ң /ŋ/ 生 сәң i й /i/ &lt;/br&gt; /y/ 西 сәй &lt;/br&gt; 需 сөй u у /u/ 收 сәу 鼻音独立韵 粤拼 西里尔 国际音标 例字 m м /m/ 唔 м ng ң /ŋ/ 吴 ң 声调用阿拉伯数字1-6或者1-9，可以上标也可以不上标。也可以不标声调。 例句 识得唔识得啊？粤拼：Sik1 dak1 m4 Sik1 dak1 aa3?西里尔：Сик1 дәк1 м4 сик1 дәк1 а3? 春眠不觉晓，处处闻啼鸟。夜来风雨声，花落知多少？粤拼：Ceon1 min4 bat1 gok3 hiu2, cyu3 cyu3 man4 tai4 niu5. Je6 loi4 fung1 jyu5 sing1, faa1 lok6 zi1 do1 siu2?西里尔：Чөн1 мин4 бәт1 гок3 хиу2, чү3 чү3 мән4 тәй4 ниу5. Йе6 лой4 фуң1 ү5 сиң1, фа1 лок6 џи1 до1 сиу2? 苟利国家生死以，岂因祸福避趋之。粤拼：Gau2 lei6 gwok3 gaa1 sang1 sei2 ji5, hei2 jan1 wo5 fuk1 bei6 ceoi1 zi1.西里尔：Гәу2 лей6 гуок4 га1 сәң1 сей2 и5, хей2 йән1 во5 фук1 бей6 чөй1 џи1.]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>文字游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些奇奇怪怪的编程语言]]></title>
    <url>%2F2016%2F06%2F23%2F%E9%82%A3%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[原发在十五言。现在十五言和果壳网一样，死了。 世界上的编程语言，按照其应用领域，可以粗略地分成三类。 有的语言是多面手，在很多不同的领域都能派上用场。这类编程语言叫 general-purpose language，简称 GPL。大家学过的编程语言很多都属于这一类，比如说 C，Java， Python。 有的语言专注于某一特定的领域，甚至只能用在特定的软件中。这类编程语言叫 domain-specific language，简称 DSL。典型的例子如 Game Maker Language，只用在一个叫 Game Maker 的游戏开发软件中。 有的语言则完全没什么卵用。它们设计出来根本不是为了实用的目的，而是为了搞笑，为了玩梗，为了开脑洞，为了证明某个概念，为了测试语言设计的界限，或者纯粹是为了让你没法好好编程……这些语言往往怪里怪气的，一看就不是正经的编程语言。 这就是 esoteric programming language。虽说也可以简称 EPL，但一般人不这样叫，而是取 esoteric 的前两个音节和 language 的第一个音节，叫它 esolang。 Esoteric programming language 这个词有点不好翻译。中文维基百科把它译成“深奥的编程语言”——这个翻译让总我觉得有点深奥。知乎的@涛吴 则把它译成“蛋疼编程语言”——蛋疼一词与 esoteric 差别有点大，但用在 esolang 身上还挺贴切。 程序员在正经的工作中当然不会用到 esolang。Esolang 的使用者和创作者主要是一个由爱好者组成的小圈子，圈子中有程序员，有计算机科学家，有业余学习编程的人，也有像我这样基本不会编程的人。他们活跃在互联网的各个角落，还建起了一个叫 Esolang 的维基网站。 说了这么多，举个例子。 Brainfuck脑……操？ 没错，这种 esolang 就叫 brainfuck。 看名字就知道不是什么正经的编程语言。 名字虽然不正经，这却是最著名的一种 esolang。很多地方都可以看到它的身影，比如说 Stack Overflow 的404页面： Brainfuck 的语法非常简单，只有八条指令。除了指令之外，只有一个由很多个存储单元组成的数组（可以想像成一条有无数个格子的纸带），一个指向数组的指针。开始的时候，数组的每个存储单元都被初始化为0，指针指着数组的第一个存储单元。八条指令对应于数组和指针的八个操作： &gt; 指针向右移动一位&lt; 指针向左移动一位+ 指针指向的存储单元加一- 指针指向的存储单元减一. 将指针指向的存储单元的内容作为字符输出, 输入一个字符并保存到指针指向的存储单元[ 如果指针指向的存储单元为零，向后跳转到对应的 ] 指令处] 如果指针指向的存储单元不为零，向前跳转到对应的 [ 指令处 这里的方括号其实就相当于 C 语言里的 while 循环。 除了这八条指令以外的所有字符都会被忽略。你可以把它们当成注释。 按照传统，学习编程时的第一个范例程序往往是输出字符串Hello, World!。我们就用 brainfuck 来写一个 Hello World 程序吧。 首先，字母H的 ASCII 码是72，而存储单元的初始值为0。于是我们需要72个+，然后用.输出： ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 然后，e的 ASCII 码是101，比72多了29，于是我们加上29个+，再用.输出。后面的11个字符也同样处理。最终写出来的程序是： ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++.+++++++. .+++.-------------------------------------------------------------------.------------.+++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++.+++.------.--------.-------------------------------------------------------------------. 长得有点离谱。不过我们只用了一个存储单元，没有移动过指针，也没有用上循环。用上一些技巧之后，代码可以缩短很多，比如说下面这个 primo 写的 Hello World 程序只有87个字符： ---&gt;-&gt;-&gt;&gt;+&gt;+&gt;&gt;+[++++[&gt;+++[&gt;++++&gt;--&gt;+++&lt;&lt;&lt;-]&lt;-]&lt;+++]&gt;&gt;&gt;.&gt;--&gt;-.&gt;..+&gt;++++&gt;+++.+&gt;--&gt;[&gt;-.&lt;&lt;] 感兴趣的读者可以在这个 brainfuck 在线解释器上试试这些代码。 可以看出，brainfuck 语言的可读性非常糟糕，一个 Hello World 程序就已经完全让人看不懂了。 这样的语言有什么用呢？ 文章一开头我就说过了：没什么卵用。没人会用它来写实用的程序。 不过总是能找到一点用处的吧？ 一个用处是当成智力题。用 brainfuck 写程序相当考验智力，稍复杂一点的程序写起来就有一种脑子被操的感觉。 另一个用处是用来拼成字符画。由于每个指令只有一个字符，而且可以任意插入别的字符，例如空格和换行，因此很容易把 brainfuck 程序打扮成字符画。就像这样： 第三种用处则关系到 brainfuck 语言的一个重要特点：它是图灵完备的。 极简主义与 Turing Tarpit图灵完备不稀奇。我们熟悉的编程语言，绝大部分都是图灵完备的。神奇的地方在于，brainfuck 仅仅用了八条指令，就实现了一个图灵完备的模型。它是一种极简主义的编程语言。 从这点来说，这种语言虽然名字难听，却有着独特的美学价值。 比美学价值更重要的是，它实现起来非常简单。因此，要证明一种编程语言是图灵完备的，我们只需要用它实现一个 brainfuck，或者证明它的一个子集与 brainfuck 等价。很多 esolang 的图灵完备性就是通过 brainfuck 来证明的。 有不少 esolang 以极简主义为自己追求的目标， brainfuck 只是其中的一种。这些语言有些是图灵完备的，有些不是。其中图灵完备的那些称为 Turing tarpit ——中文维基百科把这个词译作“图灵焦油坑”。 提出 Turing tarpit 这个词的是美国计算机科学家，首届图灵奖得主 Alan Perlis。他在《Epigrams on Programming》一书中提到： Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy. 和别的 Turing tarpit——比如说，只有一条指令的单一指令计算机，基于组合子逻辑的 Jot 和 Iota，基于字符串重写的 Thue——比起来，brainfuck 有多达八条指令，算是比较复杂的一种，离极简主义的要求还是有一点距离。不过，brainfuck 还可以简化 。 首先，八条指令的操作对象是一个有很多个存储单元的数组。Brainfuck 并没有规定每个存储单元有多大，主流的 brainfuck 实现大多把它定为一个字节（byte）。我们也可以把它改成一个比特（bit）；也就是说，每个存储单元只有0和1两种状态。这样+和-就没有区别了，我们可以把这两个指令合并，写成@。 然后，我们可以用}来表示&gt;@；也就是指针向右移动一格，然后加一。注意向左移动一个和向右移动一格可以抵消，两次加一也可以抵消。由此容易看出，@就相当于&lt;}，&gt;相当于}&lt;}。于是我们可以把@换成&lt;}，&gt;换成}&lt;}，这样就只剩下}&lt;[].,这六条指令了。 六条指令还是比较多。输入输出和循环结构还可以进一步简化，甚至简化到只有三条指令。不过简化的过程比较复杂，我就不介绍了，感兴趣的读者可以看这里。 不过，经过这一步步的简化，写出有意义的程序也变得越来越难。 当然，为了实现极简主义的理想，牺牲一点易用性是值得的。 何况，有的 esolang 本来就是为了难用而设计的。 地狱级的编程语言我在文章开头就说过，某些 esolang 的设计目的，就“纯粹是为了让你没法好好编程”。 这方面最典型的例子是 Malbolge。 Malbolge 是 Ben Olmstead 发明于1998年的一种编程语言。Malbolge 这个词来自但丁《神曲・地狱篇》中的地狱第八层——Malebolge。 Malbolge 编程的难度确实称得上是地狱级。它把程序存储在一个三进制虚拟机上，运行过程中会不断地修改自身；同一个字符在程序的不同位置代表不同的指令，而有效的指令总共只有8条；每一条指令在执行之后会被“加密”，变成另一个字符…… 事实上，Ben Olmstead 本人也没有写出过一个完整的 Malbolge 程序。第一个 Malbolge 的 Hello World 程序是通过一个 LISP 程序用束搜索算法搜出来的。 这个用 LISP 找出来的 Hello World 程序长这样： (=&lt;`$9]7&lt;5YXz7wT.3,+O/o&apos;K%$H&quot;&apos;~D|#z@b=`&#123;^Lx8%$Xmrkpohm-kNi;gsedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543s+O&lt;oLm 这不是一个完美的 Hello World 程序，它输出的是“HEllO WORld”，连大小写都做不到统一。 看来这种语言真的是无解了。 但就在几年之后，Malbolge 被一位叫做 Lou Scheffer 的密码学爱好者“破解”了。 Lou Scheffer 意识到，看待 Malbolge 的正确方法是把它看作一套密码系统，而非一种编程语言。于是，他用密码学的方法对 Malbolge 进行了分析，找到了它的“弱点”，写出了几个 Malbolge 程序，还提出了一套写 Malbolge 程序的策略。有了这套策略，用 Malbolge 语言写程序依然十分困难，但已经不再是不可能。 于是，我们写 Hello World 程序的时候不必再用 LISP 来搜索。这是 Jacob 写的一个能完整输出“Hello, World!”的程序： (&apos;&amp;%:9]!~&#125;|z2Vxwv-,POqponl$Hjihf|B@@&gt;,=&lt;M:9&amp;7Y#VV2TSn.Oe*c;(I&amp;%$#&quot;mCBA?zxxv*Pb8`qo42mZF.&#123;Iy*@dD&apos;&lt;;_?!\&#125;&#125;|z2VxSSQ 当然，我还是读不懂。 无论是追求极简的 Turing tarpits，还是追求极难的 Malbolge，都可以归结为测试语言设计的界限。正如 Ben Olmstead 在某次采访中所说的： … pushing the boundaries of programming… but not in useful directions. 有的语言则走得更远，突破了维度的界限。 二维的编程语言无论是大部分日常的编程语言，还是前面介绍的 brainfuck 和 Malbolge，代码都是一维的。即使有换行和缩进的要求，读代码的时候还是从前往后按顺序阅读。 你有没有想过，有的语言可以把代码铺在一个二维的平面上，用箭头或别的符号来指引阅读和执行的方向，读代码就像走迷宫？ 比如说 Befunge。 Befunge 是一个基于堆栈的编程语言，大部分指令都是堆栈操作：往堆栈里压入一个东西，从堆栈里弹出一个东西，交换堆栈顶部的两个东西……Befunge 中也有加减乘除、模、逻辑非、大于等常见的运算，只不过要理解为堆栈操作。比如说，加法+表示从堆栈里弹出两个数，把它们加起来，然后把结果压回堆栈。 基于堆栈的编程语言不常见，但也算不上离奇。有些实用的编程语言，比如说 PostScript，Forth，Factor，也是基于堆栈的，只不过 Befunge 里每一条指令都只用一个字符来表示。 除了堆栈操作的指令之外，Befunge 中还有一些指示方向的指令。比如说，^v&lt;&gt;分别表示上下左右四个方向的箭头；问号?表示随机的一个方向；|和_这两个符号表示条件选择，比如说_表示从堆栈里弹出一个值，如果它等于0就转向右边，否则转向左边。此外，#表示跳过一个指令，@表示结束程序。 这些指示方向的指令规定了代码执行的顺序：开始的时候，也是从左上角开始向右走，但并不理会换行；一旦遇到指示方向的指令，它就会转向这些指令所指的方向，沿着这个方向走下去。 于是，在 Befunge 里，你看不到别的语言中的循环语句；只要用箭头画出一个回路，就可以实现循环。 比如说，这是一个死循环： &gt;v^&lt; 再比如说 Matrix67 的博客里的这个 Hello World 程序： v&gt;v&quot;Hello world!&quot;0&lt;,:^_25*,@ 这个程序该怎么读？ 首先，从第一行的最左边开始向右走，直到碰到最右边的v。顺着v的方向向下走，遇到&lt;，转向左边。遇到0，把数字0压入堆栈。 然后我们看到了熟悉的&quot;Hello world!&quot;。但这时程序运行的方向是从右往左，所以这个字符串其实是&quot;!dlrow olleH&quot;。为什么要倒过来？因为 Befunge 处理字符串的方式是把它拆成一个个字符，按顺序压入堆栈。因此，把&quot;!dlrow olleH&quot;压入堆栈的时候，!在最下面，H在最上面。输出的时候，就可以先输出H，最后输出!。 &quot;Hello world!&quot;的后面是一个向下的箭头。顺着箭头，程序进入了一个由箭头围成的回路： &gt;v,:^_ 进入循环之后遇到的第一个非箭头的指令是:，它的意思是把堆栈最顶上的东西复制一份。需要复制是因为在条件选择_中要用掉一份。然后，如果堆栈顶上不是0，则向左拐，再向上，遇到,指令，输出一个字符，向右走回到v处；如果堆栈顶上是0，则在_处直接向右拐退出循环。&quot;Hello World!&quot;这几个字符都不等于0，于是程序把它们按顺序一个个输了出来。 出了循环向右走，是数字2和数字5——Befunge 里的数字要分开一个个读——和一个乘号。2乘5等于10，对应的是换行的 ASCII 码，于是后面的一个,输出换行。最后@结束程序。 Befunge 不是唯一一个二维的 esolang。Esolang 维基的 Two-dimensional languages 分类里列出了一百多种二维编程语言，其中有 Befunge 的模仿者，也有一些脑洞特别大的作品，比如说 Piet。 我也曾写过一个 Piet 程序： 没错，这幅图片就是一个 Piet 程序。这种语言的设计目标就是让程序看起来像抽象画。Piet 这个名字正是来自荷兰风格派画家 Piet Mondrian。 更多的脑洞Befunge 把程序写到二维，Piet 把程序写成图片，都算得上是脑洞之作。 日常的编程语言往往被看作是工具。无论语言本身设计得多精美，多神奇，我们更看重的往往还是写出来的程序；语言本身的精美和神奇之处也往往只是为了写出更好的程序，或者更好地写出程序。 但很多 esolang 并非如此。这些语言并不适合于写程序，令人赞叹的只是语言本身。与其把它们看作编程的工具，不如把它们看成是恰好能用来编程的艺术品。 既然是艺术品，当然可以天马行空，脑洞大开。有怎样的脑洞，就有怎样的编程语言。 下面列举了一些我比较喜欢的作品，限于篇幅就不详细介绍了。 MarioLANG把程序写成超级马里奥关卡的样子。设计者是 Wh1teWolf。 ++++: &gt; &gt; +:+:+:+:+:+:+:::::====+ &gt;^=== &quot;&quot;&quot;================= +:-):(:^= = ! ========= = # = ! .+.,:-&lt; =### ======&quot; Starry原悠在《Rubyで作る奇妙なプログラミング言語》一书中设计的编程语言。代码全是星星，读起来有一种仰望星空的感觉。 + + * + * + . + + * + * * + . + * + . + . + * + . + + * + * * + . + * + . + + * + * * + . + * + . + * + . + * + . + * + . + + * + * * + . Parenthesis HellQpliu 设计的一种 LISP 方言，继承了 LISP 最重要的特点：括号。 ((())(((())()((())())(()())((())())(((())())(((())())(()())((())())(())(()))())(())))((())())(()())((())())(((())())(((())())(()())((())())(())(()))())(())) Unreadable完全不可读的编程语言，代码中只允许出现两种字符：单引号和双引号。作者是 TehZ。 &apos;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&apos;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&apos;&quot;&apos;&quot;&quot;&apos;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&apos;&quot;&quot;&quot; Quipu古印加人有一套结绳记事的方法，叫做奇普。这种语言就是基于奇普而设计，作者是 Vladimir Kostyukov。 &quot;0 1 2 3 4 5 6 7 8&quot;\/ 1&amp; 3&amp; 4&amp; 3&amp; 7&amp; 3&amp; 1&amp; 7&amp; -- [] [] [] [] [] ^^ [] 0&amp; 1&amp; 2&amp; 6&amp; /\ -- 7&amp; [] -- [] == 7&amp; 1&amp; &gt;&gt; -- 7&amp; ++ &apos;, [] &gt;&gt; &apos;. 7&amp; [] /\ 1&amp; /\ [] ** &apos; &gt;&gt; ** 1&amp; /\ 0&amp; ++ [] ++ 8&amp; == Hexagony可能是第一种六边形编程语言。不仅代码要排成六边形，它模拟的存储布局也是一个六边形网格。作者是 Martin Büttner。 4 \ / &quot; 1 &quot; 0 . &quot; . . . 0 . . 0 . = . \ 0 0 0 / + .&#125; = \ &gt; - &quot; &lt; &gt; &amp; . + &amp; . / &lt; . _ &#125; &apos; . . ) _ ! \ + &#123; = / @ &#123; &#123; &#125; = + Rail把代码铺成铁路。作者是 Jonathon Duerig。 $ &apos;main&apos; (--): \ | /---------\ | | | | \ /-io-/ \---e-&lt; \-# Polynomial这是 Maedhros777 设计的一种语言。一个程序就是一个多项式，指令隐藏在多项式的零点当中。 f(x) = x^10 - 4827056x^9 + 1192223600x^8 - 8577438158x^7 + 958436165464x^6 - 4037071023854x^5 + 141614997956730x^4 - 365830453724082x^3 + 5225367261446055x^2 - 9213984708801250x + 21911510628393750 Velato程序既然能写成图片，当然也能写成音乐。Velato 是一种以 MIDI 音乐为源代码的编程语言，作者是 Rottytooth。 除此之外，还有一些更加优秀的作品，出自 Danger Mouse（Piet 的作者）、Timwi 这样的 esolang 大师之手。如果这一系列没有坑掉的话，我会在以后专门用一两篇文章介绍他们的作品。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>Esolang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也来设计一个拼音方案]]></title>
    <url>%2F2016%2F06%2F18%2F%E6%88%91%E4%B9%9F%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8B%BC%E9%9F%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在知乎看到一个贴子，该贴楼主设计了一套汉语拼音方案，挺好玩的。 我也一直有自己设计一套拼音方案的想法。于是基于上个世纪30年代鞑靼语的Jaꞑalif字母表，设计了一套富有异域风情的拼音方案。 反正就是图个好玩，完全不考虑实用性。 声母表格中左边加粗的是我设计的拼音方案，右边是原本的汉语拼音。 双唇音/唇齿音 齿龈音 卷舌音 龈颚音 软颚音 鼻音 m m n n 塞音（不送气） b b d d g g 塞音（送气） p p t t k k 塞擦音（不送气） z z ƶ zh ƣ j 塞擦音（送气） c c ç ch q q 擦音（清） f f s s ş sh x x h h 擦音（浊） r r 边音 l l 韵母表格中左边加粗的是我设计的拼音方案，右边是原本的汉语拼音。 开口呼 齐齿呼 合口呼 撮口呼 ь i i i u u y ü a a ja ia va ua o o vo uo ə e e ê je ie ye üe ər er aj ai vaj uai ej ei vej uei (ui) av ao jav iao ov ou jov iou (iu) an an jan ian van uan yan üan ən en in in vən uen (un) yn ün aꞑ ang jaꞑ iang vaꞑ uang əꞑ eng iꞑ ing uꞑ ong juꞑ iong vəꞑ ueng 声调可以不标。需要标记时，第一声不标，二、三、四声分别用音节后加上ƨ、з、ч来表示。轻声不标，也可以在其前方用一个小点.来表示。为避免与句号混淆，在真正的句号后若不换行，一定要加上空格。 隔音符号两个音节分界处，第二个音节开头是零声母，可能引起混淆时，用隔音符号’来隔开。 例句 我能吞下玻璃而不伤身体。汉语拼音：Wǒ néng tūnxia bōli ér bù shāng shēntǐ.我的方案（不标声调）：Vo nəꞑ tvənxja boli ər bu şaꞑ şənti.我的方案（标记声调）：Voз nəꞑƨ tvən.xja bo.li ərƨ buч şaꞑ şəntiз. 人人生而自由，在尊严和权利上一律平等。他们赋有理性和良心，并应以兄弟关系的精神互相对待。汉语拼音：Rénrén shēng ér zìyóu, zài zūnyán hé quánlì shàng yílǜ píngděng. Tāmen fùyǒu lǐxìng hé liángxīn, bìng yīng yǐ xiōngdi guānxì de jīngshén hùxiāng duìdài.我的方案（不标声调）：Rənrən şəꞑ ər zьjov, zaj zvəꞑjan hə qyanli şaꞑ ily piꞑdəꞑ. Tamən fujov lixiꞑ hə ljaꞑxin, biꞑ iꞑ i xjuꞑdi gvanxi də ƣiꞑşən huxjaꞑ dvejdaj.我的方案（标记声调）：Rənƨrənƨ şəꞑ ərƨ zьчjovƨ, zajч zvəꞑjanƨ həƨ qyanƨliч şaꞑч ilyч piꞑƨdəꞑз. Ta.mən fuчjovз liзxiꞑч həƨ ljaꞑƨxin, biꞑч iꞑ iз xjuꞑdiч gvanxiч .də ƣiꞑşənƨ huчxjaꞑ dvejчdajч. 苟利国家生死以，岂因祸福避趋之。汉语拼音：Gǒu lì guó jiā shēng sǐ yǐ, qǐ yīn huò fú bì qū zhī.我的方案（不标声调）：Gov li gvo ƣja şəꞑ sь i, qi in hvo fu bi qy ƶь.我的方案（标记声调）：Govз liч gvoƨ ƣja şəꞑ sьз iз, qiз in hvoч fuƨ biч qy ƶь.]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>文字游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10个惊艳的Mathematica单行代码]]></title>
    <url>%2F2016%2F05%2F28%2F10%E4%B8%AA%E6%83%8A%E8%89%B3%E7%9A%84Mathematica%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[几年前兴起过一个“10个惊艳的XX单行代码”的潮流。始作俑者好象是Marcus Kazmierczak的《10 Scala One Liners to Impress Your Friends》，然后出现了各种其它语言的版本。 我不是编程工作者，现在才看到那些文章，跟风写了个Mathematica版。不过很多功能在Mathematica里都可以直接用一个函数搞定，看起来不是那么惊艳。 需要Mathematica 10.1以上的版本。 1. 列表每项乘以2Range[10] * 2 2. 列表求和Fold[Plus, Range[1000]]Total[Range[1000]] 3. 验证字符串中是否存在某词wordList = &#123;"coffeescript", "eko", "play framework", "and stuff", "falsy"&#125;tweet = "This is an example tweet talking about javascript and stuff."StringContainsQ[tweet, wordList] 4. 读取文件fileText = Import["data.txt"]fileLines = Import["data.txt", "List", "Numeric" -&gt; False] 5. 生日歌Do[Print["Happy Birthday " &lt;&gt; If[i == 3, "dear NAME", "to You"]], &#123;i, 4&#125;] 6. 过滤列表中的数字&#123;passed, failed&#125; = Lookup[GroupBy[&#123;49, 58, 76, 82, 88, 90&#125;, # &gt; 60 &amp;], &#123;True, False&#125;, &#123;&#125;] 7. 读取和分析XML Web serviceresults = Import["http://search.twitter.com/search.atom?&amp;q=scala", "XML"] 8. 寻找列表中最大最小值Min[&#123;14, 35, -7, 46, 98&#125;]Max[&#123;14, 35, -7, 46, 98&#125;] 9. 并行处理result = ParallelMap[processItem, dataList] 10. 埃拉托斯特尼筛法Reap[Range[2, #] //. p : &#123;x_, ___&#125; :&gt; Complement[p, Range[0, #, Sow[x]]]][[2, 1]] &amp;]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个二维码]]></title>
    <url>%2F2016%2F05%2F20%2F%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语言之墙]]></title>
    <url>%2F2016%2F03%2F30%2F%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%A2%99%2F</url>
    <content type="text"><![CDATA[魔法不过是一类特殊的语言。拦截魔法的结界，自然也能拦截一般的语言。这样的结界叫做“语言之墙”（gisgaja ŋulibama）。乌图语中“语言”（ŋuliba）和“魔法”（ŋulibu）只差一个字母，很多古典时期之后的方言更是取消了这个区别。对这些方言的使用者来说，语言之墙就是魔法之墙。 第一座大规模的语言之墙的建造者是安思陀罗帝国——它只是乌图帝国瓦解后冒出来的无数个大大小小的“帝国”之一，统治的疆域未曾达到过乌图帝国全盛时的五分之一，但它的财力已足以支撑起这么一个庞大的工程。 这座语言之墙建造在帝国北方的边境上，目的是防御北方的海盗。它不是用砖石砌成，而是用语言编制而成——确切地说，用的是诗歌。整座语言之墙就是一首长诗，也许是人类所创作的最长的诗歌之一——当然，除了卅猫百科。这首长诗本身有时由无数较短的诗歌组成，有普通的、不带魔法的诗歌，也有咒文。这无数的诗歌交织在一起，组成一张大网。任何魔法——以及语言——想要越过帝国的国境线，都要经过这张网的筛选。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海盗]]></title>
    <url>%2F2016%2F03%2F30%2F%E6%B5%B7%E7%9B%97%2F</url>
    <content type="text"><![CDATA[北土北面是北海，北海边上是海盗们生活的地方。 他们不是真正的海盗，也从未干过杀人越货的勾当，“海盗”（乌图语Pirata，海盗语Pyret）只是别人对他们的称呼。他们是来自乌图帝国的萨满的后代。 乌图帝国有过一段一神教神权统治的时代，一神教信仰被强加到人们的头上。但萨满的理念与一神教的信仰并不兼容：卅猫的思想更倾向于无神论或不可知论，而一神教的教义也有反魔法的倾向。 一些萨满选择了妥协，表面上接受了一神教，继续生活在帝国的统治之下，甚至出任帝国的官职。一些不愿合作的萨满，则来到了北海边上。这里名义上也是帝国的领地，但从未得到有效的统治，帝国也并不在乎这片贫瘠的土地。 土地虽然贫瘠，他们还是活了下来。他们为当地的原住民带来了先进的魔法，原住民则教给了他们捕鱼的技术。逐渐地，他们与原住民融合，形成了一套独特的文化。 他们有了自己的宗教。为了表达对一神教的讽刺，他们按照南土“触手越多的神越强大”的信条，为自己的神添加了无数面条般的触手，比一神教所信仰的赫屠鲁要多得多。 他们也有了自己的语言。它是乌图语的一种方言，融合了一些原住民的词汇和语法，还将大量的咒语直接用在日常的语言当中。这便是海盗语。 他们不再服从帝国的统治，还建立了自己的武装力量。在乌图帝国看来，武装反抗帝国的统治，便是盗；又生活在海边，因此便是海盗。海盗们欣然接受了这一称呼，还模仿帝国的骑士团，将自己的武装力量命名为盗士团。 直到乌图帝国灭亡多年之后，北海盗士团依然是北土的一支重要的势力。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百科全书]]></title>
    <url>%2F2016%2F03%2F30%2F%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[百科全书，在乌图语中叫做维基亚（vikia）。 这又是一个历史比乌图语本身还要悠久的词语。它的词源是Viki加上表示名词的后缀-a。Viki便是维基岛，是北土与南土间的一个小岛的名字。这是卅猫百科（Samavikia）的第一个版本写成的地方。 卅猫百科并非第一本百科全书，也非卅猫所写，起这个名字只是为了向卅猫致敬。事实上，在卅猫的时代，人类还没有自己的文字，更谈不上什么书。卅猫传授的知识，主要还是口头传播，偶尔也用兽人的文字来记录。 与知识一同被传播的，是卅猫发明的各种小游戏，其中的一种文字游戏便是最早的魔法。当时的魔法确实只是个游戏，它能做到的不过是把词句颠来倒去，删掉一些词，添上一些词…… 卅猫的弟子是第一代萨满。经过一代又一代萨满的努力，萨满们的知识变得丰富起来。原来的文字游戏也已经变成了文字魔法，成为了处理文字的利器，被萨满们用来辅助诗歌的创作。 一位萨满开始整理这些知识，试着将它们编写成长篇的诗歌。对这么长的一首诗歌来说，无论是编写还是阅读都是一件繁重的任务。于是，他采用了一种全新的写法。魔法不仅被用在诗歌的创作过程中，还大量地插入到诗歌当中。咒语太多，读起来就不顺畅，于是他又用了一些手法，将诗中的咒语巧妙地隐藏了起来。 最终，写出来的诗歌不同于以往的任何一首诗歌：不同于寻常的诗歌，咒语在这首诗中占了极大的篇幅；又不同于咒文，你在诵读的时候不会读出任何咒语；你不仅可以像普通的诗歌一样，从开头一直读到结尾；也可以在读到某个词的时候，激活其中的魔法，诗歌便会跳转到另一个章节。 这首诗便是百科全书的雏形。受它的影响，最早的百科全书都是以诗歌的形式出现。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔法阵]]></title>
    <url>%2F2016%2F03%2F30%2F%E9%AD%94%E6%B3%95%E9%98%B5%2F</url>
    <content type="text"><![CDATA[魔法（ŋulibu）一词有两种含义：狭义的魔法，仅指咒文（rimu）、咒语（slovin）等语言的魔法；广义的魔法，则包含了包括狭义的魔法在内的各种奇妙的法术。 魔法阵便是语言的魔法以外的另一种魔法。 魔法阵比语言的魔法要少见得多，学习起来也更加困难。但它与语言的魔法遵循着类似的逻辑。事实上，它与咒文是等价的：任一个能用咒文产生的效果都能用魔法阵来实现，反之亦然。 其实，魔法阵是一种特殊的文字，一种二维的文字。它并不记录任何语言。它与人们日常使用的文字有着共同的起源：都是来自于远古的图画文字。但是，图画文字逐渐向着更适合记录语言的方向发展，表音的符号越来越多，也变得越来越抽象；魔法阵却走上了另一条道路：它同样是变得更加抽象，却去除了原本图画文字中刚刚显出雏形的标音符号，离人们所说的语言越来越远……仔细观察，依稀还能从那繁杂的图案中识别出主谓宾，但人类语言的语序对它而言已毫无意义。 但是，在乌图帝国末年，一位萨满却提出了一个有趣的观点：魔法阵并非不记录任何语言；相反，它能同时记录世界上的所有语言。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傀儡]]></title>
    <url>%2F2016%2F03%2F30%2F%E5%82%80%E5%84%A1%2F</url>
    <content type="text"><![CDATA[兽人曾建立起发达的文明，但他们从未掌握能成为生产力的魔法。不过，在北土西部流传的一些民间传说中，兽人有傀儡。 傀儡是傀儡木（Guelemu）的简称，或者称为哥廉（Golem）——这只是同一个词在不同的方言中的念法。它们原本是用粘土或别的材料制成的粗糙的人形。然后，只需要经过一个简单的步骤——在不同版本的传说中，这一步骤也完全不同——这些人形就会活动起来，像人一样，去劳动，去战斗。这一步骤，便是傀儡的秘密。 兽人比人类更强壮，更聪明，掌握的技术也更先进，与人类相比唯一的缺陷就在于繁殖能力较低，人口不足。而傀儡正好在一定程度上弥补了这一缺陷。 根据这些传说，在人类与兽人的战争中，人类攻打兽人乌煞部的一座城池的时候，便遇上了由傀儡组成的大军。面对这支数量庞大而又不惧死亡的军队，人类束手无策。 但是，人类的军师拇姬便是叛逃过来的兽人，他知晓傀儡的秘密。于是，拇姬仅仅采取了一个简单的计策——关于这个计策，不同版本的传说里的说法也完全不同——人类便顺利地击败了傀儡大军。 在诸多不同版本的传说中，有一个看起来最像是真的。在这里，制作傀儡的那一步骤，是为它起一个名字；而拇姬的对策，也是给这些傀儡另起一个名字——借助人类的人口优势，人类所使用的名字便成了它们真正的名字，于是，这些傀儡也成了人类的傀儡。 当然，传说只是传说，无论是考古还是严肃的史诗中都无法找到任何傀儡存在过的证据。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兽人]]></title>
    <url>%2F2016%2F03%2F30%2F%E5%85%BD%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[在龙的文明衰亡之后，第一个建立起先进的文明的物种，不是人类，而是兽人。 但也有人认为，兽人并非与人类不同的物种，而只是人类的一个亚种。 人类和兽人的共同祖先——古猿诞生的那块大陆，叫做南土（Xlabat Storin）；南土的北面是一块更大的大陆，叫做北土（Xlabat Verin）。在不同的时期，由于地质的变化，或者海平面的升降，两块大陆曾多次连接或分离。 在人类尚未称为人类的时候，人类祖先的一支，趁着一次两块大陆相连的时候，来到了北土。他们便是兽人的祖先。当两块大陆再一次相连，已经是人类的人类开始进入北土的时候，兽人已经建立起了自己的文明——与当时的人类相比，是相当发达的文明。 兽人比人类更高大，更强壮，更聪明，寿命是人类的三四倍。但是，他们并没有把入侵的人类赶尽杀绝。从此开始了人类与兽人共存的时期。直到兽人中出了一个叛徒，人类才夺取了北土的统治权，最终把兽人灭绝。 人类的不同语言中对兽人有不同的称呼，这些词往往带有侮辱的意味。在人类记录下来的历史中，兽人也常被描绘成丑陋、残忍、贪婪、邪恶的形象。讽刺的是，记录下这些历史所用的文字，最初也是从兽人处学来的。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乌图语]]></title>
    <url>%2F2016%2F03%2F30%2F%E4%B9%8C%E5%9B%BE%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[乌图语（Ŋuliba Utuma），最初是乌图人（Utu）的语言。在乌图帝国（Gaŋžu Utumu）成立之后，它成了乌图帝国的语言。然后，它又成了乌图时代的语言——以世界通用的族际交际语来划分时代，是后世史学界的传统。 在乌图帝国灭亡多年（“年”这个词的使用还有争议，待改）之后，乌图语逐渐被别的语言——包括一些乌图语的方言的后裔——所取代。除了研究语言和历史的学者之外，熟练掌握乌图语的最后一个群体是魔法师。魔法的咒文必须是用乌图语或者基于乌图语的人造语言写下的诗篇。于是，乌图语的语法和修辞是魔法教育的最重要的部分之一。 根据魔法界的传统，一位魔法师学到的第一句乌图语往往是“Axoj, salkal!”其中Axoj是“你好”的意思，但这种用法在古典乌图语中并不常见，而更常出现在北方海盗所用的乌图语方言中；salkal则是“世界”的意思，这个词的历史远比乌图语本身的历史要久远，甚至可以追溯到卅猫时代——它最初指的是卅猫发明的一种叫“生命”（Uxaj）的游戏中的棋盘。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔法的起源（二）]]></title>
    <url>%2F2016%2F03%2F30%2F%E9%AD%94%E6%B3%95%E7%9A%84%E8%B5%B7%E6%BA%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[人类的魔法和龙的魔法一样，也是语言的游戏。 人类最早的魔法便是卅猫的文字游戏。在卅猫刚设计出这个游戏的时候，它还不是魔法，游戏中的“魔法词”也仅仅是一些附带了规则的标签，让玩家根据这些规则来改变句子的内容；但当这个游戏在卅猫的弟子——萨满当中传播开来，并成为萨满这个群体的语言的一部分的时候，那些“魔法词”变真的有了魔法。这是作用于语言的魔法，所以也可以当作是作用于魔法的魔法——后来有的人把这种魔法称为“元魔法”。但在那个时候，它仅仅是流传在萨满间的一种游戏。 在传播的过程中，一些萨满给这个游戏增加了一些新的魔法词，或者更改原有的魔法词的含义，这个游戏逐渐变的强大。然后，有的萨满看到了它的用处，开始用它来辅助自己创作诗歌和音乐。那些魔法词就直接插入在押韵的诗歌当中。这样用起来并不方便，于是他们就专门写出一些包含大量魔法词的诗歌，然后用这些诗歌来处理别的诗歌。这种诗歌便是最早的咒文。咒文一定要押韵，这条规矩就是那时形成的。 每次都要吟诵完整的诗歌，还是不太方便。于是萨满们给诗歌起了标题，在使用的时候只要念出诗歌的标题。这些标题便是咒语。咒语不仅可以单独使用，还可以像魔法词那样插入诗歌当中。魔法词也被视为一种咒语——事实上，当一种来自咒文的标题的咒语被萨满们普遍使用的时候，它就跟魔法词没有任何区别了。于是，渐渐地，人们就只说“咒语”而不说“魔法词”了。 在乌图语中，咒文叫做rimu，词源来自于“韵律”；咒语唤作slovin，词源来自“词语”；魔法则称为ŋulibu，词源来自“语言”。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火球术]]></title>
    <url>%2F2016%2F03%2F30%2F%E7%81%AB%E7%90%83%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[火球术是最广为人知的魔法之一。但它的发明者却不是人类，而是龙。 在人类还是古猿的时候，龙就已经建立起了自己的文明。它们有自己的语言，自己的魔法——语言即是魔法。魔法不在语音当中，而在语义当中。气流从肺部喷出，冲过咽腔和口腔，冲击着声带、会厌、悬雍垂和舌头，发出一声龙的嘶吼。但这个声音仅仅是一个声音。只有当它有了约定的含义，它才是一个词。而约定的语法，又将一个个词语粘成句子，最后称为常常的咒文。当一条龙念完火球术的咒文，一团火焰便从它的口中产生，又随着语言的气流从口中喷出。 但随着语言的演变，火球术这个常用魔法的咒文逐渐地缩短，最终缩成一个词：“呵呵”（Xorxor）。此后，这个词就不再变化。直到龙的文明衰落、灭亡，苟延残喘在山区中的幸存的龙也遗忘了一切别的魔法，甚至语言也已经退化，“呵呵”却一直没有改变。 人类文明兴起之后，人类的萨满为了研究火球术，也曾尝试模仿龙的嘶吼声。但他们没能成功地从口中喷出火球，因为“呵呵”在人类的语言中不是火球术的咒语。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔法的起源]]></title>
    <url>%2F2016%2F03%2F30%2F%E9%AD%94%E6%B3%95%E7%9A%84%E8%B5%B7%E6%BA%90%2F</url>
    <content type="text"><![CDATA[传说中，魔法的创始人是卅猫（Samau）。 人们已经难以考证卅猫是什么年代的人物。关于卅猫的传说流传在各个不同的民族，不同的传说之间又有不少互相矛盾的地方。甚至考古挖掘出来的兽人的石碑上也记载了卅猫的故事——这样我们可以断定他活跃在兽人灭绝之前，但这也令卅猫的身份更加扑朔迷离：连他是智人还是兽人也不知道了。 从这些传说来看，卅猫云游四方，行踪不定，在不同的地方会使用不同的化名。他似乎无所不知，又充满智慧。他有无数的发明创造，其中包括了不少小游戏。例如，一种叫做“生命”（Uxaj）的元胞自动机游戏。他把游戏中的棋盘称为“世界”（salkal）——“世”（sal）指棋盘上的纵线，“界”（kal）指棋盘上的横线。后来，人们用这个词来借指整个世界，而忘了“世界”一词本来的含义。 他发明的另一种游戏则被认为是魔法的起源。这是一种文字游戏：在句子中插入一些“魔法词”，然后根据一定的规则——不同的“魔法词”对应不同的规则，比如说调换词的顺序、删掉一些词、把一些词换成另一些词——来改写句子，直到这些“魔法词”全部消失。这和今天的魔法非常不同：它的作用范围仅仅是语言本身，而不是自然界。 卅猫曾收过一些弟子，弟子们又收了更多的弟子，形成了一个特殊的群体。他们自称萨满（Saman），意为“卅猫的门徒”。他们从卅猫处学到了关于自然的知识，也学到了文字游戏。他们便是魔法师的前身。和现代的魔法师不同，那时的萨满更多的是学者和哲学家。正是他们把卅猫发明的简单的文字游戏，发展成了一套具有强大力量的严密的体系。]]></content>
      <tags>
        <tag>简书搬运</tag>
        <tag>卅猫传说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Mathematica 转发网漫]]></title>
    <url>%2F2016%2F03%2F26%2F%E7%94%A8Mathematica%E8%BD%AC%E5%8F%91%E7%BD%91%E6%BC%AB%2F</url>
    <content type="text"><![CDATA[此文本来是发在果壳日志的，发表时间是2013年6月26日。现在果壳日志下线了，搬来这里。 注意：在最新版的 Mathematica 11.3 中这里的代码已无法使用。我尝试把URLFetch改写成URLExecute，但并不成功。最后只能不再用Mathematica自带的处理网络请求的函数，而是调用cURL。修改后的代码和这里已经完全不同，请见GitHub. 以下是原文： (*_*) 前一段时间无聊，在微博上注册了个马甲与小号（好吧，小号暴露了），又顺手写了一段Mathematica代码，专门用来转发网漫。 这里就说说我是怎么干的吧。 首先，要申请一个微博APP。申请了之后，你就获得了一个access_token。然后就可以用它来发微博了。 发微博要用到新浪微博的API接口。比如说，发不带图片的微博用statuses/update： URLFetch["https://api.weibo.com/2/statuses/update.json", "Method" -&gt; "POST", "Parameters" -&gt; &#123;"access_token" -&gt; "你的access_token", "status" -&gt; "喵呜。"&#125;] 发带图片的微博用statuses/upload。这个比较麻烦，要采用multipart/form-data编码方式。我琢磨了很久才弄明白这个用Mathematica怎么弄。反正代码差不多是这样： URLFetch["https://api.weibo.com/2/statuses/upload.json", "Method" -&gt; "POST", "MultipartData" -&gt; &#123;&#123;"access_token", "", ToCharacterCode@"你的access_token"&#125;, &#123;"status", "", ToCharacterCode["@拇姬 ", "UTF8"]&#125;, &#123;"pic\"; filename=\"mandrill.png", "image/png", ImportString[ ExportString[ExampleData[&#123;"TestImage", "Mandrill"&#125;], "PNG"], "Binary"]&#125;&#125;] （不用UTF8编码的话可能会导致乱码。） 发图片的时候要先导出成PNG或者别的图片格式再导入成二进制形式，还是挺麻烦的。不过如果是网上的图片或者电脑里本来有的图片，就省去了第一步。 （注意：由于2017年7月的微博接口更新，以上方法以不适用，无论发带图片或不带图片的微博都改用statuses/share接口，而且所发的内容有一些奇怪的限制。） 然后是网漫。我是通过网漫RSS来获取网漫。RSS是XML格式，Mathematica可以把XML格式文件导入成Mathematica的树状结构，然后模式匹配什么的用起来还是很方便的。 麻烦就在于有些网漫的RSS在一个叫feeds.feedburner.com的网站上。这个网站被墙了…… 如果有好用的翻墙工具的话，这个不是问题。在Mathematica中可以方便地设置代理服务器： UseInternetProxy[True];SetInternetProxy["HTTP", &#123;"代理服务器的地址", 端口&#125;]; 读取完了RSS，在发微博的时候可以关掉代理： UseInternetProxy[False]; 然后从RSS中读出内容、图片地址、链接、发表日期等信息。我把每次转发漫画时把其中最新的一期的发表日期存在一个叫做webcomics.mx的文件中，以后只转发这个日期之后的漫画，这样就可以做到不重不漏。 下面是转发网漫的完整代码： (* 请设成脚本所在的目录 *)SetDirectory[ FromCharacterCode[ ToCharacterCode@"/home/alephalpha/文档/马甲与小号/WebComics/", "UTF8"]];accessToken = "████不████给████你████看████";appURL = " http://example.com";(* 请根据所使用的翻墙软件修改此处的参数 *)SetInternetProxy["HTTP", &#123;"127.0.0.1", 8087&#125;];ProxyImport[url_, options___] := Module[&#123;data&#125;, UseInternetProxy[True]; data = Import[url, options]; UseInternetProxy[False]; data];(* 上传图片，发布微博，并记录原漫画的发布时间 *)Post[name_][pubDate_, title_, link_, image_String] := URLFetch["https://api.weibo.com/2/statuses/share.json", "Method" -&gt; "POST", "MultipartData" -&gt; &#123;&#123;"access_token", "", ToCharacterCode@accessToken&#125;, &#123;"status", "", ToCharacterCode[ "【" &lt;&gt; name &lt;&gt; "】" &lt;&gt; link &lt;&gt; " " &lt;&gt; title &lt;&gt; appURL, "UTF8"]&#125;, &#123;"pic\"; filename=\"" &lt;&gt; StringDelete[image, ___ ~~ "/"], "image/" &lt;&gt; StringDelete[image, ___ ~~ "."], Import[image, "Binary"]&#125;&#125;, "StoreCookies" -&gt; False];Post[name_][pubDate_, title_, link_, image_Integer: 1] := Post[name][pubDate, title, link, Import[link, "ImageLinks"][[image]]];(* 根据 pattern 来从 RSS 中获取信息，并用 Post 函数发布微博 *)ShareWebComics[name_, rss_, pattern_] := Module[&#123;data&#125;, data = Sort[ Select[Cases[ProxyImport[rss, "XML"], pattern, &#123;0, Infinity&#125;], First@# &gt; Lookup[pubDates, name, 0] &amp;]]; Post[name] @@@ data; pubDates[name] = Max[Lookup[pubDates, name, 0], First /@ data];];Get["webcomics.mx"];ShareWebComics["xkcd", "http://xkcd.com/rss.xml", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], XMLElement["link", &#123;&#125;, &#123;link_&#125;], XMLElement["description", &#123;&#125;, &#123;description_&#125;], XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], title, link, First@ StringCases[description, "&lt;img src=\"" ~~ Shortest[src__] ~~ "\"" ~~ ___ :&gt; src]&#125;];ShareWebComics["Buni", "http://www.bunicomic.com/feed/", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;"Buni"&#125;], XMLElement["link", &#123;&#125;, &#123;link_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___, XMLElement["description", &#123;&#125;, &#123;description_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], "", link, First@StringCases[description, "src=\"" ~~ Shortest[src__] ~~ "-150x150" ~~ Shortest[fmt__] ~~ "\"" ~~ ___ :&gt; src &lt;&gt; fmt]&#125;];ShareWebComics["Optipess", "http://feeds.feedburner.com/Optipess?format=xml", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___, XMLElement["category", &#123;&#125;, &#123;"Comic"&#125;], ___, XMLElement["description", &#123;&#125;, &#123;description_&#125;], ___, XMLElement[&#123;___, "origLink"&#125;, &#123;&#125;, &#123;link_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], title, link, First@StringCases[description, "&lt;img src=\"" ~~ Shortest[src__] ~~ "\"" ~~ ___ :&gt; src]&#125;];ShareWebComics["Buttersafe", "http://feeds.feedburner.com/Buttersafe?format=xml", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___, XMLElement["category", &#123;&#125;, &#123;"Comic"&#125;], ___, XMLElement["description", &#123;&#125;, &#123;description_&#125;], ___, XMLElement[&#123;___, "origLink"&#125;, &#123;&#125;, &#123;link_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], title, link, First@StringCases[description, "&lt;img src=\"" ~~ Shortest[src1__] ~~ "/rss" ~~ Shortest[src2__] ~~ "RSS" ~~ Shortest[src3__] ~~ "\"" ~~ ___ :&gt; src1 &lt;&gt; src2 &lt;&gt; src3]&#125;];ShareWebComics["SMBC", "http://www.smbc-comics.com/rss.php", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], XMLElement["description", &#123;&#125;, &#123;description_&#125;], XMLElement["link", &#123;&#125;, &#123;link_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], StringDrop[title, 36], link, First@StringCases[description, "&lt;img src=\"" ~~ Shortest[src__] ~~ "\"" ~~ ___ :&gt; src]&#125;];ShareWebComics["SpikedMath", "http://feeds.feedburner.com/SpikedMath?format=xml", XMLElement["entry", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], ___, XMLElement["published", &#123;&#125;, &#123;pubDate_&#125;], ___, XMLElement["content", &#123;___&#125;, &#123;description_&#125;], ___, XMLElement[&#123;___, "origLink"&#125;, &#123;&#125;, &#123;link_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@pubDate, title, link, First@StringCases[description, "&lt;img src=\"" ~~ Shortest[src__] ~~ "\"" ~~ ___ :&gt; src]&#125;];ShareWebComics["don't shoot the pianist", "http://euge.ca/feed/", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], XMLElement["link", &#123;&#125;, &#123;link_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], title, link&#125;];ShareWebComics["ExtraOrdinary", "http://www.exocomics.com/feed", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], XMLElement["link", &#123;&#125;, &#123;link_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___, XMLElement[&#123;_, "encoded"&#125;, &#123;&#125;, &#123;description_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], title, link, First@StringCases[description, "src=\"" ~~ Shortest[src1__] ~~ "/feed" ~~ Shortest[src2__] ~~ "\"" ~~ ___ :&gt; src1 &lt;&gt; "/comics" &lt;&gt; src2]&#125;];ShareWebComics["pbfcomics", "http://www.pbfcomics.com/feed/feed.xml", XMLElement["entry", &#123;&#125;, &#123;XMLElement["id", &#123;&#125;, &#123;link_&#125;], XMLElement["title", &#123;_&#125;, &#123;title_&#125;], XMLElement["updated", &#123;&#125;, &#123;updated_&#125;], ___, XMLElement["summary", &#123;_&#125;, &#123;description_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@updated, title, link, First@StringCases[description, " src=\"" ~~ Shortest[src__] ~~ "\"" ~~ ___ :&gt; src]&#125;];ShareWebComics["Geek&amp;Poke", "http://feeds.feedburner.com/GeekAndPoke", XMLElement["item", &#123;&#125;, &#123;XMLElement["title", &#123;&#125;, &#123;title_&#125;], ___, XMLElement["pubDate", &#123;&#125;, &#123;pubDate_&#125;], ___, XMLElement["description", &#123;&#125;, &#123;description_&#125;], ___, XMLElement[&#123;___, "origLink"&#125;, &#123;&#125;, &#123;link_&#125;], ___&#125;] :&gt; &#123;AbsoluteTime@StringDrop[pubDate, -5], title, link, First@StringCases[description, " data-image=\"" ~~ Shortest[src__] ~~ "\"" ~~ ___ :&gt; src]&#125;];DumpSave["webcomics.mx", pubDates]; 第一次运行之前要先把pubDates设定成一个空的Association： pubDates = &lt;||&gt; 然后，如果用的是Linux，还可以把这段保存在一个Mathematica脚本中，然后用cron定时执行这个脚本，就可以做到自动转发了。 就这样吧。]]></content>
      <tags>
        <tag>Mathematica</tag>
        <tag>简书搬运</tag>
      </tags>
  </entry>
</search>
